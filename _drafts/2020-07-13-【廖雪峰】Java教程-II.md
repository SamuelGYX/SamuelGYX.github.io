---
layout: post
title:  【廖雪峰】Java教程 II
date:   2020-07-16
categories: Java
---



## 第三章 异常处理

#### 1. Java 的异常

- 发展
  - 所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错
  - 调用方如何获知调用失败的信息？有两种方法
    - 方法一：约定返回错误码
      - 常见于底层C函数
    - 方法二：在语言层面上提供一个异常处理机制
- 定义
  - Java的异常是`class`，`Throwable`是异常体系的根，它继承自`Object`
- 分类
  - `Error`：表示严重的错误，程序对此一般无能为力
  - `Exception`：运行时的错误，它可以被捕获并处理
    - `RuntimeException`
    - 非 `RuntimeException` 
- 分类 2
  - 必须捕获的异常
    - 包括`Exception`及其子类，但不包括`RuntimeException`及其子类，这种类型的异常称为Checked Exception
    - 如果程序中没有捕获语句则会出现编译失败
  - 不需要捕获的异常
    - 包括`Error`及其子类，`RuntimeException`及其子类
    - 编译器不做强制要求，但是是否需要捕获需要具体分析
- 捕获异常
  - 在方法定义的时候，使用`throws Xxx`表示该方法可能抛出的异常类型
  - 只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获，或者抛出

#### 2. 捕获异常

- catch 语句
  - 可以使用多个`catch`语句，每个`catch`分别捕获对应的`Exception`及其子类
  - 匹配到某个`catch`后，执行`catch`代码块，然后不再继续匹配
  - 因此，存在多个`catch`的时候，`catch`的顺序非常重要，子类必须写在前面
- finally 语句
  - `finally`语句块保证有无错误都会执行
  - 特点
    - `finally`语句不是必须的，可写可不写
    - `finally`总是最后执行
  - 某些情况下，可以没有`catch`，只使用`try ... finally`结构
- 捕获多种异常
  - 如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条`catch`子句
  - 我们可以把多个异常类型用`|`合并到一起

#### 3. 抛出异常

- 异常的传播
  - 通过`printStackTrace()`可以打印出方法的调用栈
- 抛出异常
  - 创建某个`Exception`的实例
  - 用`throw`语句抛出
- 异常的转换
  - 定义
    - 如果一个方法捕获了某个异常后，又在`catch`子句中抛出新的异常，就相当于把抛出的异常类型“转换”了
  - 注意
    - 新的异常丢失了原始异常信息
    - 为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息
  - 查看
    - 在代码中获取原始异常可以使用`Throwable.getCause()`方法。如果返回`null`，说明已经是“根异常”了
- finally 的执行顺序
  - 在同一个代码块中，throw 之后的语句都不会被执行
  - 但是，在 finally 中的语句除外，程序总会执行完 finally 之后才抛出异常
- 异常屏蔽
  - 定义
    - 如果在 finally 中有抛出异常，则原来在 catch 中准备抛出的异常就“消失”了
    - 没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）
  - 处理方法
    - 如果要保存被屏蔽的异常，需要先用变量保存原始异常，然后调用`Throwable.addSuppressed()`，把原始异常添加进来
    - 通过`Throwable.getSuppressed()`可以获取所有的`Suppressed Exception`
  - 注意
    - 因此，绝大多数情况下，在`finally`中不要抛出异常

#### 4. 自定义异常

- 抛出异常时，尽量复用JDK已定义的异常类型
- 自定义异常体系时，推荐从`RuntimeException`派生“根异常”，再派生出业务异常
- 自定义异常时，应该提供多种构造方法

#### 5. NullPointerException

- 定义
  - 如果一个对象为`null`，调用其方法或访问其字段就会产生`NullPointerException`
  - 属于 `RuntimeException`
- 处理
  - `NullPointerException`是Java代码常见的逻辑错误，应当早暴露，早修复
  - 可以启用Java 14的增强异常信息来查看`NullPointerException`的详细错误信息

#### 6. 断言

- 定义

  - 断言（Assertion）是一种调试程序的方式，在Java中，使用`assert`关键字来实现断言

  - 断言成功，则程序正常运行，断言失败，抛出`AssertionError`

  - ```java
    assert x >= 0 : "x must >= 0";
    ```

- 使用
  - 断言失败时会抛出`AssertionError`，导致程序结束退出
  - 因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段
  - 对于可恢复的程序错误，不应该使用断言
- 注意
  - 要执行`assert`语句，必须给Java虚拟机传递`-enableassertions`（可简写为`-ea`）参数启用断言
  - 实际开发中，很少使用断言，更好的方法是编写单元测试 `JUnit`

#### 7. JDK Logging

- 定义

  - 日志就是Logging，它的目的是为了取代`System.out.println()`

- 优势

  - 可以设置输出样式，自动打印时间、调用类、调用方法等很多有用的信息
  - 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志
  - 可以被重定向到文件，这样可以在程序运行结束后查看日志
  - 可以按包名控制日志级别，只输出某些包打的日志

- 使用

  - Java标准库内置了日志包`java.util.logging`

  - ```java
    Logger logger = Logger.getGlobal();
    logger.info("start process...");
    logger.warning("memory is running out...");
    ```

  - 7 个日志级别

    - SEVERE
    - WARNING
    - INFO
    - CONFIG
    - FINE
    - FINER
    - FINEST

  - 默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来

- 问题

  - Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行`main()`方法，就无法修改配置
  - 配置不太方便，需要在JVM启动时传递参数`-Djava.util.logging.config.file=<config-file-name>`

#### 8. Commons Logging

- 简介

  - Commons Logging是一个第三方日志库，它是由Apache创建的日志模块
  - 是使用最广泛的日志模块，API 简单，还可以自动检测并使用其他日志模块
  - 特色是可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统
  - 默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging

- 通用使用

  - 第一步，通过`LogFactory`获取`Log`类的实例

  - 第二步，使用`Log`实例的方法打日志

  - ```java
    Log log = LogFactory.getLog(Main.class);
    log.info("start...");
    log.warn("end.");
    ```

  - 6 个日志级别，默认级别是`INFO`

    - FATAL
    - ERROR
    - WARNING
    - INFO
    - DEBUG
    - TRACE

  - Commons Logging的日志方法，例如`info()`，除了标准的`info(String)`外，还提供了一个非常有用的重载方法：`info(String, Throwable)`，这使得记录异常更加简单

- 使用

  - 静态方法

    - 通常直接定义一个静态类型变量

    - ```java
      static final Log log = LogFactory.getLog(Main.class);
      ```

  - 实例方法

    - 通常定义一个实例变量

    - ```java
      protected final Log log = LogFactory.getLog(getClass());
      ```

    - 注意：可以使用 `<Class-Name>.class` 代替 `getClass()`， 但这种写法的好处在于，子类可以直接使用该`log`实例，无需改动代码

#### 9. Log4j

- 简介
  - 前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j
- 构件
  - Appender
    - 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地
  - Filter
    - 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出
  - Layout
    - 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息
  - 目的地
    - console：输出到屏幕
    - file：输出到文件
    - socket：通过网络输出到远程计算机
    - jdbc：输出到数据库
- 使用
  - 配置文件
    - 把一个`log4j2.xml`的文件放到`classpath`下就可以让Log4j读取配置文件并按照我们的配置来输出日志
  - 依赖包
  - 调用 Commons Logging
    - 因为Commons Logging会自动发现并使用Log4j，所以要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出
- 编程规范
  - 在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j
  - 如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入`classpath`，就可以自动把日志切换成使用Log4j写入，无需修改任何代码

#### 10. SLF4J 和 Logback

- 简介
  - SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现
  - Java有着非常悠久的开源历史，开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库
  - 因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback



## 第四章 反射

- 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息
- 反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法

#### 1. Class 类

- 