---
layout: post
title:  【廖雪峰】Java教程 II
date:   2020-07-16
categories: Java
---



## 第六章 泛型

#### 1. 简介

- 泛型就是编写模板代码来适应任意类型
- 泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查
- 注意泛型的继承关系：可以把`ArrayList<Integer>`向上转型为`List<Integer>`（`T`不能变！），但不能把`ArrayList<Integer>`向上转型为`ArrayList<Number>`（`T`不能变成父类）

#### 2. 使用泛型

- 用法
  - 使用泛型时，把泛型参数`<T>`替换为需要的class类型，例如：`ArrayList<String>`，`ArrayList<Number>`等
  - 可以省略编译器能自动推断出的类型，例如：`List<String> list = new ArrayList<>();`
  - 不指定泛型参数类型时，编译器会给出警告，且只能将`<T>`视为`Object`类型
- 接口
  - 可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型

#### 3. 编写泛型

- 写法
  - 编写泛型时，需要定义泛型类型`<T>`
- 静态方法
  - 静态方法不能直接使用 class 的泛型类型 `<T>`，只能自己定义另一个类型 `<K>`
  - 静态方法的泛型类型和实例类型的泛型类型（`<T>` 与 `<K>`）没有任何关系，各自独立
- 多种泛型
  - 泛型可以同时定义多种类型，例如`Map<K, V>`

#### 4. 原理：擦拭法

- 泛型原理

  - 泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同
  - Java语言的泛型实现方式是擦拭法（Type Erasure）

- 擦拭法

  - 特点
    - 虚拟机对泛型其实一无所知，所有的转换工作都是编译器做的
  - 实现
    - 编译器把类型`<T>`视为`Object`
    - 编译器根据`<T>`实现安全的强制转型

- 局限性

  - `<T>`不能是基本类型

    - 例如`int`，因为实际类型是`Object`，`Object`类型无法持有基本类型

  - 无法取得带泛型的`Class`

    - 所有泛型实例，无论`T`的类型是什么，`getClass()`返回同一个`Class`实例，因为编译后它们全部都是`class_name<Object>`

  - 无法判断带泛型的类型

    - ```java
      Pair<Integer> p = new Pair<>(123, 456);
      if (p instanceof Pair<String>) {} // Compile error:
      // 正确写法：p instanceof Pair<?> 或者 p instanceof Pair
      ```

  - 不能实例化`T`类型

    - ```java
      first = new T(); // Compile error:
      ```

    - 要实例化`T`类型需要借助反射

- 覆写方法

  - 泛型方法要防止重复定义方法，例如：`public boolean equals(T obj)`

- 泛型继承

  - 一个类可以继承自一个泛型类
  - 子类可以获取父类的泛型类型`<T>`

#### 5. extends 通配符

- 定义方法参数

  - 上界通配符（Upper Bounds Wildcards）

  - 使用

    - ```java
      static int add(Pair<? extends Number> p) {
          Number first = p.getFirst();
          Number last = p.getLast();
          return p.getFirst().intValue() + p.getFirst().intValue();
      }
      ```

  - 作用

    - 使得方法接收所有泛型类型为`Number`或`Number`子类的`Pair`类型，例如 `Pair<Integer>, Pair<Double>`
    - 对参数`Pair<? extends Number>`进行只读操作（恶意调用`set(null)`除外）

  - 注意

    - 返回值类型

      - ```java
    Integer x = p.getFirst(); // 编译错误
        Number x = p.getFirst();  // 正确，使用上界接收返回值
        ```
    
  - 因为实际的返回类型可能是`Integer`，也可能是`Double`或者其他类型，编译器只能确定类型一定是`Number`的子类
  
- 传入参数
  
      - ```java
        p.setFirst(new Integer(first.intValue() + 100));
        // 编译错误
        // 唯一的例外是可以给方法参数传入 null，使用下界传入参数
    ```
    
      - 这是因为 p 内部的 `<T>` 可能是 Number 或其子类，并不存在一个下界类型，可以自动转换成 Number 或其任意子类
      
      - 因此，方法参数类型`<? extends Integer>`表明了该方法内部只会读取参数的内部元素，不会修改元素（因为无法调用`set, add, remove`这些方法）
    ```
  
- 定义泛型类型

  - ```java
    public class Pair<T extends Number> { ... }
    ```

  - 泛型类型限定为`Number`以及`Number`的子类

#### 6. super 通配符

- 定义方法参数

  - 使用

    - ```java
      void set(Pair<? super Integer> p, Integer first, Integer last) {
          p.setFirst(first);
          p.setLast(last);
      }
      ```

  - 作用

    - 使得方法参数接受所有泛型类型为`Integer`或`Integer`父类的`Pair`类型
    - 表示方法内部代码对于参数只能写，不能读（强制转换为 Object 除外）

  - 注意

    - 返回值类型

      - ```java
        Integer x = p.getFirst();  // 编译错误
        Object obj = p.getFirst(); // 正确，使用上界接收返回值
        ```

    - 传入参数

      - ```java
        p.setFirst(new Integer(100)); // 正确，使用下界传入参数
        ```

- 对比

  - extends

    - `<? extends T>`允许调用读方法`T get()`获取`T`的引用，但不允许调用写方法`set(T)`传入`T`的引用（传入`null`除外）
    - 允许读不允许写

  - super

    - `<? super T>`允许调用写方法`set(T)`传入`T`的引用，但不允许调用读方法`T get()`获取`T`的引用（获取`Object`除外）
    - 允许写不允许读

  - 举例

    - ```java
      public static <T> void copy(List<? super T> dest, List<? extends T> src) {
          for (int i=0; i<src.size(); i++) {
              T t = src.get(i);
              dest.add(t);
          }
      }
      ```

    - 作用

      - 保证只读 src，只写 dest
      - 可以安全地把一个`List<Integer>`添加到`List<Number>`，但是无法反过来添加

- PECS原则

  - Producer Extends Consumer Super
  - 如果需要返回`T`，它是生产者（Producer），要使用`extends`通配符
  - 如果需要写入`T`，它是消费者（Consumer），要使用`super`通配符

- 无限定通配符 `<?>`

  - 作用
    - 不允许调用`set(T)`方法并传入引用（`null`除外）
    - 不允许调用`T get()`方法并获取`T`引用（只能获取`Object`引用）
  - 补充
    - 大多数情况下，可以引入泛型参数`<T>`消除`<?>`通配符
    - `Pair<?>`是所有`Pair<T>`的超类

#### 7. 泛型和反射

- 部分反射API是泛型，例如：`Class<T>`，`Constructor<T>`
- 可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型
- 可以通过`Array.newInstance(Class<T>, int)`创建`T[]`数组，需要强制转型
- 同时使用泛型和可变参数时需要特别小心



## 第七章 集合

#### 1. 简介

- Collection
  - Java标准库自带的`java.util`包提供了集合类：`Collection`，它是除`Map`外所有其他集合类的根接口
- 集合类型
  - List
    - 有序列表的集合
  - Set
    - 保证没有重复元素的集合
  - Map
    - 通过键值（key-value）查找的映射表集合
- 特点
  - 实现了接口和实现类相分离，例如，有序表的接口是`List`，具体的实现类有`ArrayList`，`LinkedList`等
  - 支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素
  - Java访问集合总是通过统一的方式——迭代器（Iterator）来实现
- 历史遗留
  - Hashtable：一种线程安全的`Map`实现
  - Vector：一种线程安全的`List`实现
  - Stack：基于`Vector`实现的`LIFO`的栈
  - Enumeration<E> 接口：已被`Iterator<E>`取代

#### 2. List

- 简介

  - 在集合类中，`List`是最基础的一种集合：它是一种有序列表
  - `List`的行为和数组几乎完全相同，但封装了很多操作链表

- 接口方法

  - 在末尾添加一个元素：`boolean add(E e)`
  - 在指定索引添加一个元素：`boolean add(int index, E e)`
  - 删除指定索引的元素：`int remove(int index)`
  - 删除某个元素：`int remove(Object e)`
  - 获取指定索引的元素：`E get(int index)`
  - 获取链表大小（包含元素的个数）：`int size()`

- 实现方式

  - `ArrayList`：数组
  - `LinkedList`：链表
  - 通常情况下，我们总是优先使用`ArrayList`

- 常用操作

  - 创建

    - ```java
      List<String> list = new ArrayList<>();
      List<Integer> list = List.of(1, 2, 5);
      ```

  - 遍历

    - ```java
      for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
          String s = it.next();
          System.out.println(s);
      }
      // 只要实现了Iterable接口的集合类都可以直接用for each循环来遍历
      for (String s : list) {
          System.out.println(s);
      }
      ```

  - 转换

    - ```java
      // List to Array
      Object[] array = list.toArray(); // 丢失类型信息，所以实际应用很少
      Integer[] array = list.toArray(new Integer[list.size()]);
      Integer[] array = list.toArray(Integer[]::new);
      ```

    - ```java
      List<Integer> list = List.of(array); // 返回的是一个只读List
      List<Integer> list = Arrays.asList(array);
      ```

#### 3. List：equals 方法

- 需求
  - 在`List`中查找元素时，`List`的实现类通过元素的`equals()`方法比较两个元素是否相等，因此，放入的元素必须正确覆写`equals()`方法
- 方法要求
  - 自反性（Reflexive）
  - 对称性（Symmetric）
  - 传递性（Transitive）
  - 一致性（Consistent）
  - 对`null`的比较
- 编写方法
  - 先确定实例“相等”的逻辑
  - 用`instanceof`判断传入的待比较的`Object`是不是当前类型
  - 对引用类型用`Objects.equals()`比较，对基本类型直接用`==`比较
- 补充
  - 使用`Objects.equals()`比较两个引用类型是否相等的目的是省去了判断`null`的麻烦
  - 如果不调用`List`的`contains()`、`indexOf()`这些方法，那么放入的元素就不需要实现`equals()`方法

#### 4. Map

- 简介

  - `Map<K, V>`是一种键-值映射表
  - 和`List`类似，`Map`也是一个接口，最常用的实现类是`HashMap`

- 常用方法

  - 创建

    - ```java
      Map<String, Integer> map = new HashMap<>();
      ```

  - 存储

    - ```java
      map.put("apple", 123);
      ```

    - Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉

  - 获取

    - ```java
      Integer i = map.get("pear")
      ```

    - 如果`key`不存在，则返回`null`

  - 查找

    - ```java
      boolean containsKey(K key)
      ```

  - 遍历

    - ```java
      for (String key : map.keySet())
          Integer value = map.get(key);
      for (Map.Entry<String, Integer> entry : map.entrySet()) {
          String key = entry.getKey();
          Integer value = entry.getValue();
      }
      ```

    - 注意：Map 的遍历不保证顺序

#### 5. Map：equals 和 hashCode

- 正确使用`Map`必须保证

  - 作为`key`的对象必须正确覆写`equals()`方法
  - 作为`key`的对象还必须正确覆写`hashCode()`方法
    - 如果两个对象相等，则两个对象的`hashCode()`必须相等
    - 如果两个对象不相等，则两个对象的`hashCode()`尽量不要相等
  - 补充：对于放入`HashMap`的`value`对象，没有任何要求

- equals 和 hashCode 编写原则

  - `equals()`用到的用于比较的每一个字段，都必须在`hashCode()`中用于计算
  - `equals()`中没有使用到的字段，绝不能放在`hashCode()`中计算

- 实现

  - 实现`hashCode()`方法可以通过`Objects.hashCode()`辅助方法实现

  - ```java
    @Override
    int hashCode() {
        return Objects.hash(firstName, lastName, age);
    }
    ```

- 内部原理

  - `HashMap`初始化时默认的数组大小只有16

  - 添加超过一定数量的`key-value`时，`HashMap`会在内部自动扩容，每次扩容一倍

    - 频繁扩容对`HashMap`的性能影响很大，更好的方式是创建`HashMap`时就指定容量

    - ```java
      Map<String, Integer> map = new HashMap<>(10000);
      // 虽然指定容量是10000，但HashMap内部的数组长度总是2^n，因此，实际数组长度被初始化为比10000大的16384（2^14）
      ```

  - 在哈希冲突的时候，一种最简单的解决办法是用`List`存储`hashCode()`相同的`key-value`

#### 6. Map：EnumMap

- 简介

  - 如果作为key的对象是`enum`类型，那么，还可以使用Java集合库提供的一种`EnumMap`
  - 它在内部以一个非常紧凑的数组存储value，并且根据`enum`类型的key直接定位到内部数组的索引，并不需要计算`hashCode()`，不但效率最高，而且没有额外的空间浪费

- ```java
  Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);
  ```

#### 7. Map：TreeMap

- SortedMap

  - `HashMap`是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的
  - 还有一种`Map`，它在内部会对Key进行排序，这种`Map`就是`SortedMap`。注意到`SortedMap`是接口，它的实现类是`TreeMap`

- 特点

  - `SortedMap`保证遍历时以Key的顺序来进行排

- 注意

  - 使用`TreeMap`时，放入的Key必须实现`Comparable`接口，作为Value的对象则没有任何要求

  - 如果作为Key的class没有实现`Comparable`接口，那么，必须在创建`TreeMap`时同时指定一个自定义比较算法

    - ```java
      Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {
          public int compare(Person p1, Person p2) {
              return p1.name.compareTo(p2.name);
          }
      });
      ```

  - `TreeMap`不使用`equals()`和`hashCode()`

  - `TreeMap`在比较两个Key是否相等时，依赖Key的`compareTo()`方法或者`Comparator.compare()`方法。在两个Key相等时，必须返回`0`

#### 8. Map：Properties

- 简介

  - Java集合库提供的`Properties`用于读写配置文件`.properties`
  - `Properties`内部本质上是一个`Hashtable`，但我们只需要用到`Properties`自身关于读写配置的接口

- 读取

  - 步骤

    - 创建`Properties`实例
    - 调用`load()`读取文件
    - 调用`getProperty()`获取配置

  - 举例

    - ```java
      Properties props = new Properties();
    
      String f = "setting.properties";
      props.load(new java.io.FileInputStream(f));
    
      String filepath = props.getProperty("last_open_file");
      String interval = props.getProperty("auto_save_interval", "120");
      ```

  - 补充

    - `load(InputStream)` 方法接收一个`InputStream`实例，表示一个字节流

    - ```java
      // 文件流
      props.load(new java.io.FileInputStream("setting.properties"));
      // 从jar包中读取的资源流
      props.load(getClass().getResourceAsStream("/common/setting.properties"));
      // 从内存读取一个字节流
      String settings = "# test" + "\n" + "course=Java";
      props.load(new ByteArrayInputStream(settings.getBytes("UTF-8")));
      ```

    - 如果有多个`.properties`文件，可以反复调用`load()`读取，后读取的key-value会覆盖已读取的key-value

    - 可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置

- 问题

  - 除了`getProperty()`和`setProperty()`方法外，还有从`Hashtable`继承下来的`get()`和`put()`方法
  - 我们在使用`Properties`的时候，不要去调用这些从`Hashtable`继承下来的方法

- 写入

  - store()

  - ```java
    props.setProperty("url", "http://www.liaoxuefeng.com");
    props.setProperty("language", "Java");
    props.store(new FileOutputStream("C:\\conf\\setting.properties"), "这是写入的properties注释");
    ```

- 编码

  - 早期版本的Java规定`.properties`文件编码是ASCII编码（ISO8859-1）

  - 从JDK9开始，Java的`.properties`文件可以使用UTF-8编码

  - 由于`load(InputStream)`默认总是以ASCII编码读取字节流，我们需要用另一个重载方法`load(Reader)`读取

  - ```java
    props.load(new FileReader("settings.properties", StandardCharsets.UTF_8));
    ```

  - `InputStream`和`Reader`的区别是一个是字节流，一个是字符流。字符流在内存中已经以`char`类型表示了，不涉及编码问题

#### 9. Set

- 简介
  - `Set`用于存储不重复的元素集合
  - `Set`实际上相当于只存储key、不存储value的`Map`
  - 最常用的`Set`实现类是`HashSet`，实际上，`HashSet`仅仅是对`HashMap`的一个简单封装
- 常用方法
  - 添加
    - `boolean add(E e)`
    - 元素已存在则添加失败，返回 false
  - 删除
    - `boolean remove(Object e)`
    - 元素不存在则删除失败，返回 false
  - 查询
    - `boolean contains(Object e)`
- 注意
  - 放入`Set`的元素和`Map`的key类似，都要正确实现`equals()`和`hashCode()`方法
  - `Set`接口并不保证有序
- 分类
  - 与 Map 非常类似
  - Set 接口
    - HashSet 实现：无序
    - SortedSet 接口
      - TreeSet 实现：有序
- TreeSet
  - 使用`TreeSet`和使用`TreeMap`的要求一样，添加的元素必须正确实现`Comparable`接口，如果没有实现`Comparable`接口，那么创建`TreeSet`时必须传入一个`Comparator`对象

#### 10. Queue

- 简介

  - `Queue`实际上是实现了一个先进先出（FIFO：First In First Out）的有序表

- 操作

  - 把元素添加到队列末尾
  - 从队列头部取出元素

- 常用方法

  - `int size()`
    - 获取队列长度
  - `boolean add(E)`/`boolean offer(E)`
    - 添加元素到队尾
  - `E remove()`/`E poll()`
    - 获取队首元素并从队列中删除
  - `E element()`/`E peek()`
    - 获取队首元素但并不从队列中删除

- 补充

  - 对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有

  - 注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的

    |                    | throw Exception | 返回false或null    |
    | :----------------- | :-------------- | ------------------ |
    | 添加元素到队尾     | add(E e)        | boolean offer(E e) |
    | 取队首元素并删除   | E remove()      | E poll()           |
    | 取队首元素但不删除 | E element()     | E peek()           |

  - 不要把`null`添加到队列中，否则`poll()`方法返回`null`时，很难确定是取到了`null`元素还是队列为空

- 面向抽象编程

  - `LinkedList`即实现了`List`接口，又实现了`Queue`接口

  - 在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用

  - ```java
    List<String> list = new LinkedList<>();
    Queue<String> queue = new LinkedList<>();
    ```

#### 11. Queue: PriorityQueue

- 简介

  - `PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关

- 注意

  - 放入`PriorityQueue`的元素，必须实现`Comparable`接口，或者提供一个`Comparator`对象，`PriorityQueue`会根据元素的排序顺序决定出队的优先级

  - ```java
    Queue<User> q = new PriorityQueue<>(new UserComparator());
    
    class UserComparator implements Comparator<User> {
        public int compare(User u1, User u2) {
            return Objects.compare(u1.name, u2.name)
        }
    }
    ```

#### 12. Queue：Deque

- 简介

  - `Queue`是队列，只能一头进，另一头出
  - 如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名`Deque`
  - `Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`

- 对比

  |                    | Queue                  | Deque                           |
  | :----------------- | :--------------------- | :------------------------------ |
  | 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |
  | 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |
  | 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |
  | 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |
  | 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |
  | 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |
  - `Deque`接口实际上扩展自`Queue`
  - 因此，`Queue`提供的`add()`/`offer()`方法在`Deque`中也可以使用，但是，使用`Deque`，最好不要调用`offer()`，而是调用`offerLast()`

- 面向抽象

  - 我们发现`LinkedList`真是一个全能选手，它即是`List`，又是`Queue`，还是`Deque`

  - 但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途

  - ```java
    // 不推荐的写法:
    LinkedList<String> d1 = new LinkedList<>();
    d1.offerLast("z");
    // 推荐的写法：
    Deque<String> d2 = new LinkedList<>();
    d2.offerLast("z");
    ```

  - 可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类

#### 13. Stack

- 简介
  - 栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构
- 操作
  - 把元素压栈：`push(E)`
  - 把栈顶的元素“弹出”：`pop(E)`
  - 取栈顶元素但不弹出：`peek(E)`
- 实现：`Deque`
  - 把元素压栈：`push(E)`/`addFirst(E)`；
  - 把栈顶的元素“弹出”：`pop(E)`/`removeFirst()`；
  - 取栈顶元素但不弹出：`peek(E)`/`peekFirst()`
- 补充
  - 为什么Java的集合类没有单独的`Stack`接口呢？因为有个遗留类名字就叫`Stack`，出于兼容性考虑，所以没办法创建`Stack`接口，只能用`Deque`接口来“模拟”一个`Stack`了
  - 当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰
- 作用
  - 对整数进行进制的转换
  - 计算中缀表达式

#### 14. Iterator

- 迭代器
  - Java的集合类都可以使用`for each`循环
  - 我们把这种通过`Iterator`对象遍历集合的模式称为迭代器
- 优势
  - 调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构
- 实现
  - 集合类实现`Iterable`接口，该接口要求返回一个`Iterator`对象
  - 用`Iterator`对象迭代集合内部数据

#### 15. Collections

- 简介
  - Collections，而不是 Collection

`Collections`是JDK提供的工具类，同样位于`java.util`包中。它提供了一系列静态方法，能更方便地操作各种集合

- 创建空集合

  - 方法

    - 创建空List：`List<T> emptyList()`
    - 创建空Map：`Map<K, V> emptyMap()`
    - 创建空Set：`Set<T> emptySet()`

  - 注意

    - 返回的空集合是不可变集合，无法向其中添加或删除元素

  - 补充

    - 也可以用各个集合接口提供的`of(T...)`方法创建空集合，完全等价

    - ```java
      List<String> list1 = List.of();
      List<String> list2 = Collections.emptyList();
      ```

- 创建单元素集合

  - 方法
    - 创建一个元素的List：`List<T> singletonList(T o)`
    - 创建一个元素的Map：`Map<K, V> singletonMap(K key, V value)`
    - 创建一个元素的Set：`Set<T> singleton(T o)`
  - 注意
    - 返回的单元素集合也是不可变集合，无法向其中添加或删除元素
  - 补充
    - 也可以用各个集合接口提供的`of(T...)`方法创建单元素集合
    - 实际上，使用`List.of(T...)`更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合

- 排序

  - 因为排序会直接修改`List`元素的位置，因此必须传入可变`List`

  - ```java
    Collections.sort(list);
    ```

- 洗牌

  - ```java
    Collections.shuffle(list);
    ```

- 不可变集合

  - `Collections`还提供了一组方法把可变集合封装成不可变集合
    - 封装成不可变List：`List<T> unmodifiableList(List<? extends T> list)`
    - 封装成不可变Set：`Set<T> unmodifiableSet(Set<? extends T> set)`
    - 封装成不可变Map：`Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)`
  - 注意
    - 这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的
    - 因此，返回不可变`List`后，最好立刻扔掉可变`List`的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”`List`变化了

- 线程安全集合

  - `Collections`还提供了一组方法，可以把线程不安全的集合变为线程安全的集合
    - 变为线程安全的List：`List<T> synchronizedList(List<T> list)`
    - 变为线程安全的Set：`Set<T> synchronizedSet(Set<T> s)`
    - 变为线程安全的Map：`Map<K,V> synchronizedMap(Map<K,V> m)`
  - 从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了



## 第九章 日期与时间

#### 1. 简介

- 基本概念
  - 日期
  - 时间
- 时区
  - `GMT`或者`UTC`加时区偏移
    - `GMT+08:00, UTC+08:00`
  - 缩写
    - `SCT: 表示 China Standard Time 或 Central Standard Time USA`
    - 容易混淆，不推荐
  - 以洲／城市表示
    - `Asia/Shanghai`
- 夏令时
  - 计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时
- 本地化
  - 在计算机中，通常使用`Locale`表示一个国家或地区的日期、时间、数字、货币等格式
  - `Locale`由`语言_国家`的字母缩写构成，例如，`zh_CN`表示中文+中国，`en_US`表示英文+美国

#### 2. java.util.*

- 变量本质

  - 不同的表示方法对应的是同一个时刻，时刻在计算机中存储的本质上只是一个整数，我们称它为`Epoch Time`
  - 是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数
  - Java使用`long`型来表示以毫秒为单位的时间戳，通过`System.currentTimeMillis()`获取当前时间戳

- 标准库 API

  - 旧 API
    - 定义在`java.util`这个包里面，主要包括`Date`、`Calendar`和`TimeZone`这几个类
  - 新 API
    - 新的API是在Java 8引入的，定义在`java.time`这个包里面，主要包括`LocalDateTime`、`ZonedDateTime`、`ZoneId`等

- Date

  - 简介

    - `java.util.Date`是用于表示一个日期和时间的对象，注意与`java.sql.Date`区分，后者用在数据库中

  - 基本用法

    - ```java
      // 获取当前时间:
      Date date = new Date();
      System.out.println(date.getYear() + 1900); // 必须加上1900
      System.out.println(date.getMonth() + 1); // 0~11，必须加上1
      System.out.println(date.getDate()); // 1~31，不能加1
      // 转换为String:
      System.out.println(date.toString());
      // 转换为GMT时区:
      System.out.println(date.toGMTString());
      // 转换为本地时区:
      System.out.println(date.toLocaleString());
      
      ```

  - 控制格式

    - ```java
      // 使用SimpleDateFormat针对用户的偏好精确地控制日期和时间的格式
      var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");	// 2020-07-28 12:53:08
      var sdf = new SimpleDateFormat("E MMM dd, yyyy");		// Tue Jul 28, 2020
      ```

    - 以`M`为例，假设当前月份是9月

      - `M`：输出`9`
      - `MM`：输出`09`
      - `MMM`：输出`Sep`
      - `MMMM`：输出`September`

  - 问题

    - 不能转换时区，除了`toGMTString()`可以按`GMT+0:00`输出外，Date总是以当前计算机系统的默认时区为基础进行输出
    - 也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等

- Calendar

  - 简介

    - 用于获取并设置年、月、日、时、分、秒
    - 它和`Date`比，主要多了一个可以做简单的日期和时间运算的功能

  - 基本用法

    - ```java
      // 获取当前时间:
      Calendar c = Calendar.getInstance();
      int y = c.get(Calendar.YEAR);
      int m = 1 + c.get(Calendar.MONTH);
      int d = c.get(Calendar.DAY_OF_MONTH);
      int w = c.get(Calendar.DAY_OF_WEEK);
      int hh = c.get(Calendar.HOUR_OF_DAY);
      int mm = c.get(Calendar.MINUTE);
      int ss = c.get(Calendar.SECOND);
      int ms = c.get(Calendar.MILLISECOND);
      System.out.println(y + "-" + m + "-" + d + " " + w + " " + hh + ":" + mm + ":" + ss + "." + ms);
      // 2020-7-28 3 12:56:46.442
      ```

    - `Calendar`获取年月日这些信息变成了`get(int field)`

    - 返回的年份不必转换，返回的月份仍然要加1

    - 返回的星期要特别注意，`1`~`7`分别表示 `周日，周一，……，周六`

  - 设置任意时刻

    - ```java
      // 当前时间:
      Calendar c = Calendar.getInstance();
      // 清除所有:
      c.clear();
      // 设置2019年:
      c.set(Calendar.YEAR, 2019);
      // 设置9月:注意8表示9月:
      c.set(Calendar.MONTH, 8);
      // 设置2日:
      c.set(Calendar.DATE, 2);
      // 设置时间:
      c.set(Calendar.HOUR_OF_DAY, 21);
      c.set(Calendar.MINUTE, 22);
      c.set(Calendar.SECOND, 23);
      // 利用Calendar.getTime()可以将一个Calendar对象转换成Date对象，然后就可以用SimpleDateFormat进行格式化了
      System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(c.getTime()));
      // 2019-09-02 21:22:23
      ```

  - 简单加减

    - ```java
      // 当前时间:
      Calendar c = Calendar.getInstance();
      // 清除所有:
      c.clear();
      // 设置年月日时分秒:
      c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);
      // 加5天并减去2小时:
      c.add(Calendar.DAY_OF_MONTH, 5);
      c.add(Calendar.HOUR_OF_DAY, -2);
      // 显示时间:
      var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
      Date d = c.getTime();
      System.out.println(sdf.format(d));
      // 2019-11-25 6:15:00
      ```

- TimeZone

  - 简介

    - `Calendar`和`Date`相比，它提供了时区转换的功能。时区用`TimeZone`对象表示

  - ID

    - ```java
      TimeZone tzDefault = TimeZone.getDefault(); 				// 当前时区
      TimeZone tzGMT9 = TimeZone.getTimeZone("GMT+09:00"); 		// GMT+9:00时区
      TimeZone tzNY = TimeZone.getTimeZone("America/New_York"); 	// 纽约时区
      System.out.println(tzDefault.getID()); 						// Asia/Shanghai
      System.out.println(tzGMT9.getID()); 						// GMT+09:00
      System.out.println(tzNY.getID()); 							// America/New_York
      ```

    - 时区的唯一标识是以字符串表示的ID，我们获取指定`TimeZone`对象也是以这个ID为参数获取

    - 要列出系统支持的所有ID，请使用`TimeZone.getAvailableIDs()`

  - 时区转换

    - ```java
      // 当前时间:
      Calendar c = Calendar.getInstance();
      // 清除所有:
      c.clear();
      // 设置为北京时区:
      c.setTimeZone(TimeZone.getTimeZone("Asia/Shanghai"));
      // 设置年月日时分秒:
      c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);
      // 显示时间:
      var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
      sdf.setTimeZone(TimeZone.getTimeZone("America/New_York"));
      System.out.println(sdf.format(c.getTime()));
      // 2019-11-19 19:15:00
      ```

  - 步骤

    - 清除所有字段，设定指定时区，设定日期和时间
    - 创建`SimpleDateFormat`并设定目标时区
    - 格式化获取的`Date`对象（注意`Date`对象无时区信息，时区信息存储在`SimpleDateFormat`中）

#### 3. java.time.LocalDateTime

- 简介

  - 本地日期和时间：`LocalDateTime`，`LocalDate`，`LocalTime`
  - 带时区的日期和时间：`ZonedDateTime`
  - 时刻：`Instant`
  - 时区：`ZoneId`，`ZoneOffset`
  - 时间间隔：`Duration`
  - 以及一套新的用于取代`SimpleDateFormat`的格式化类型`DateTimeFormatter`

- 改进

  - 严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便
  - 更合理的常量设计
    - Month的范围用1~12表示1月到12月
    - Week的范围用1~7表示周一到周日
  - 新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改

- LocalDateTime

  - 基本用法

    - ```java
      LocalDate d = LocalDate.now(); 			// 当前日期
      LocalTime t = LocalTime.now(); 			// 当前时间
      LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间
      System.out.println(d); 					// 严格按照ISO 8601格式打印
      System.out.println(t); 					// 严格按照ISO 8601格式打印
      System.out.println(dt); 				// 严格按照ISO 8601格式打印
      // 2020-07-29
      // 02:48:50.141491
      // 2020-07-29T02:48:50.141531
      
      LocalDate d_2 = dt.toLocalDate(); // 转换到当前日期，不会有程序运行时间的误差
      LocalTime t_2 = dt.toLocalTime(); // 转换到当前时间
      
      LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月
      LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17
      LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);
      LocalDateTime dt3 = LocalDateTime.of(d2, t2);
      ```

  - 字符串 => 日期时间

    - ```java
      LocalDateTime dt = LocalDateTime.parse("2019-11-19T15:16:17");
      LocalDate d = LocalDate.parse("2019-11-19");
      LocalTime t = LocalTime.parse("15:16:17");
      ```

  - ISO 8601 标准格式

    - 日期：yyyy-MM-dd
    - 时间：HH:mm:ss
    - 带毫秒的时间：HH:mm:ss.SSS
    - 日期和时间：yyyy-MM-dd'T'HH:mm:ss
    - 带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS

  - 加减

    - ```java
      LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
      // 加5天减3小时:
      LocalDateTime dt2 = dt.plusDays(5).minusHours(3);	// 2019-10-31T17:30:59
      // 减1月:
      LocalDateTime dt3 = dt2.minusMonths(1);				// 2019-09-30T17:30:59
      ```

    - 注意到月份加减会自动调整日期，例如从`2019-10-31`减去1个月得到的结果是`2019-09-30`，因为9月没有31日

  - 设定

    - ```java
      LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
      // 日期变为31日:
      LocalDateTime dt2 = dt.withDayOfMonth(31);	// 2019-10-31T20:30:59
      // 月份变为9:
      LocalDateTime dt3 = dt2.withMonth(9);		// 2019-09-30T20:30:59
      ```

  - 复杂运算

    - ```java
      LocalDate d = LocalDate.now();
      // 本月第一天0:00时刻: 2020-07-01T00:00
      LocalDateTime firstDay = d.withDayOfMonth(1).atStartOfDay();
      // 本月最后1天: 2020-07-31
      LocalDate lastDay = d.with(TemporalAdjusters.lastDayOfMonth());
      // 下月第1天: 2020-08-01
      LocalDate nextMonthFirstDay = d.with(TemporalAdjusters.firstDayOfNextMonth());
      // 本月第1个周一: 2020-07-06
      LocalDate firstWeekday = d.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
      ```

  - 比较

    - ```java
      LocalDateTime now = LocalDateTime.now();
      LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
      System.out.println(now.isBefore(target)); // false
      ```

  - 问题
    - `LocalDateTime`无法与时间戳进行转换，因为`LocalDateTime`没有时区，无法确定某一时刻
    - `ZonedDateTime`相当于`LocalDateTime`加时区的组合，它具有时区，可以与`long`表示的时间戳进行转换

- DateTimeFormatter

  - 基本使用

    - ```java
      // 自定义格式化:
      DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
      System.out.println(dtf.format(LocalDateTime.now()));	// 2020/07/29 03:09:29
      // 用自定义格式解析:
      LocalDateTime dt2 = LocalDateTime.parse("2019/11/30 15:16:17", dtf);
      System.out.println(dt2);								// 2019-11-30T15:16:17
      ```

- Duration 和 Period

  - 简介

    - `Duration`表示两个时刻之间的时间间隔
    - 另一个类似的`Period`表示两个日期之间的天数

  - 基本用法

    - ```java
      LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
      LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);
      Duration d = Duration.between(start, end);
      System.out.println(d); // PT1235H10M30S, 1235小时10分钟30秒
      
      Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));
      System.out.println(p); // P1M21D, 1个月21天
      
      Duration d1 = Duration.ofHours(10); 		// 10 hours
      Duration d2 = Duration.parse("P1DT2H3M"); 	// 1 day, 2 hours, 3 minutes
      ```

    - ISO 8601 格式

      - `Duration`和`Period`以`P...T...`的形式表示
      - `P...T`之间表示日期间隔，`T`后面表示时间间隔
      - `PT...`的格式表示仅有时间间隔，`P...`的格式表示仅有日期间隔

#### 4. java.time.ZonedDateTime

- 简介

  - 可以简单地把`ZonedDateTime`理解成`LocalDateTime`加`ZoneId`
  - `ZoneId`是`java.time`引入的新的时区类，注意和旧的`java.util.TimeZone`区别

- 创建

  - now()

    - ```java
      ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区
      ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York")); // 用指定时区获取当前时间
      System.out.println(zbj);	// 2020-07-29T03:32:33.420750Z[Etc/UTC]
      System.out.println(zny);	// 2020-07-28T23:32:33.422891-04:00[America/New_York]
      ```

    - 时区不同，但表示的时间都是同一时刻

  - LocalDateTime 附加 ZoneId
  
    - ```java
      LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);
      // 2019-09-15T15:16:17Z[Etc/UTC]
      ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());			
      // 2019-09-15T15:16:17-04:00[America/New_York]
    ZonedDateTime zny = ldt.atZone(ZoneId.of("America/New_York"));
      ```
      
    - 日期和时间与`LocalDateTime`相同，但附加的时区不同，因此是两个不同的时刻
  
- 时区转换

  - ```java
    // 以中国时区获取当前时间: 2020-07-29T11:38:56.451148+08:00[Asia/Shanghai]
    ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of("Asia/Shanghai"));
    // 转换为纽约时间: 2020-07-28T23:38:56.451148-04:00[America/New_York]
    ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of("America/New_York"));
    ```

- 转换为 `LocalDateTime`

  - ```java
    LocalDateTime ldt = zdt.toLocalDateTime();
    ```

  - 直接丢弃了时区信息

#### 5. java.time.DateTimeFormatter

- 简介

  - 使用旧的`Date`对象时，我们用`SimpleDateFormat`进行格式化显示。使用新的`LocalDateTime`或`ZonedLocalDateTime`时，我们要进行格式化显示，就要使用`DateTimeFormatter`
  - 和`SimpleDateFormat`不同的是，`DateTimeFormatter`不但是不变对象，它还是线程安全的

- 创建

  - 格式化字符串

    - ```java
      DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
      ```

  - 格式化字符串，同时指定`Locale`

    - ```java
      DateTimeFormatter formatter = DateTimeFormatter.ofPattern("E, yyyy-MMMM-dd HH:mm", Locale.US);
      ```

- 使用

  - ```java
    ZonedDateTime zdt = ZonedDateTime.now();
    var formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm ZZZZ");
    System.out.println(formatter.format(zdt)); 		// 2020-07-29T04:04 GMT
    var zhFormatter = DateTimeFormatter.ofPattern("yyyy MMM dd EE HH:mm", Locale.CHINA);
    System.out.println(zhFormatter.format(zdt));	// 2020 7月 29 周三 04:04
    var usFormatter = DateTimeFormatter.ofPattern("E, MMMM/dd/yyyy HH:mm", Locale.US);
    System.out.println(usFormatter.format(zdt));	// Wed, July/29/2020 04:04
    ```

  - 在格式化字符串中，如果需要输出固定字符，可以用`'xxx'`表示

- 静态方法

  - 当我们直接调用`System.out.println()`对一个`ZonedDateTime`或者`LocalDateTime`实例进行打印的时候，调用的是默认的`toString()`方法，字符串按照`ISO 8601`格式显示

  - 可以通过`DateTimeFormatter`预定义的几个静态变量来引用

  - ```java
    System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));		
    // 2019-09-15
    System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));
    // 2019-09-15T23:16:51.56217
    ```

#### 6. java.time.Instant

- 创建

  - 当前时间戳在`java.time`中以`Instant`类型表示，我们用`Instant.now()`获取当前时间戳，效果和`System.currentTimeMillis()`类似

  - ```java
    Instant now = Instant.now();
    System.out.println(now.getEpochSecond()); 	// 秒, 1595996237
    System.out.println(now.toEpochMilli()); 	// 毫秒, 1595996237247
    ```

- 转换

  - `Instant`是时间戳，给它附加上一个时区，就可以创建出`ZonedDateTime`

  - ```java
    Instant ins = Instant.ofEpochSecond(1568568760);
    ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault()); 
    // 2019-09-16T01:32:40+08:00[Asia/Shanghai]
    ```

#### 7. 最佳实践

- API 转换

  - 旧API转新API

    - ```java
      // Date -> Instant:
      Instant ins1 = new Date().toInstant();
      
      // Calendar -> Instant -> ZonedDateTime:
      Calendar calendar = Calendar.getInstance();
      Instant ins2 = Calendar.getInstance().toInstant();
      ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());
      ```

  - 新API转旧API

    - ```java
      // ZonedDateTime -> long:
      ZonedDateTime zdt = ZonedDateTime.now();
      long ts = zdt.toEpochSecond() * 1000;
      
      // long -> Date:
      Date date = new Date(ts);
      
      // long -> Calendar:
      Calendar calendar = Calendar.getInstance();
      calendar.clear();
      calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));
      calendar.setTimeInMillis(zdt.toEpochSecond() * 1000);
      ```

- 数据库

  - | 数据库    | 对应Java类（旧）   | 对应Java类（新） |
    | :-------- | :----------------- | :--------------- |
    | DATETIME  | java.util.Date     | LocalDateTime    |
    | DATE      | java.sql.Date      | LocalDate        |
    | TIME      | java.sql.Time      | LocalTime        |
    | TIMESTAMP | java.sql.Timestamp | LocalDateTime    |

  - 实际上，在数据库中，我们需要存储的最常用的是时刻（`Instant`），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间

  - ```java
    static String timestampToString(long epochMilli, Locale lo, String zoneId) {
        Instant ins = Instant.ofEpochMilli(epochMilli);
        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);
        return f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));
    }
    ```



## 第十一章 正则表达式

#### 1. 简介

- 简介
  - 正则表达式可以用字符串来描述规则，并用来匹配字符串
  - Java标准库的`java.util.regex`包内置了正则表达式引擎
- 优势
  - 只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则
  - 正则表达式是一套标准，它可以用于任何语言

#### 2. 匹配规则

- 精确匹配
  - 普通字符
    - `abc` 只能精确匹配 `abc`
  - 特殊字符
    - 用`\`转义，例如 `\&`
  - 非ASCII字符
    - 用`\u####`的十六进制表示
- 模糊匹配
  - 单个任意字符 `.`
    - 用`.`匹配一个任意字符且仅限一个字符
  - 单个数字 `\d`
    - 如果我们只想匹配`0`~`9`这样的数字，可以用`\d`匹配，且仅限单个数字字符
    - 相当于 `[0-9]`
  - 单个常用字符 `\w`
    - 用`\w`可以匹配一个字母、数字或下划线，w的意思是word
    - 相当于 `[A-Za-z0-9_]`
  - 单个空格字符 `\s`
    - 用`\s`可以匹配一个空格字符
    - 注意空格字符不但包括空格` `，还包括tab字符（在Java中用`\t`表示）
  - 反义
    - 用`\d`可以匹配一个数字，而`\D`则匹配一个非数字
    - 类似的，`\W`可以匹配`\w`不能匹配的字符，`\S`可以匹配`\s`不能匹配的字符
  - 重复匹配
    - 修饰符`*`可以匹配任意个字符，包括0个字符
    - 修饰符`+`可以匹配至少一个字符
    - 修饰符`?`可以匹配0个或一个字符
    - 修饰符`{n}`可以精确匹配n个字符
    - 修饰符`{n,m}`可以匹配n~m个字符
    - 修饰符`{n,}`可以匹配至少n个字符
- 字符分类
  - 数字 `\d`
    - `0`, `1`, `2`, ..., `9`
  - 字母
    - `a`, `b`, `c`, ..., `X`, `Y`, `Z`
  - 下划线
    - `_`
  - Unicode 字符
    - `\u548c`, ...
  - 空字符 `\s`
    - ` `, `\t`
  - 其他符号
    - `&`, `@`, `#`, `-`, ...
    - 需要在符号前加 `\`

#### 3. 复杂匹配规则

- 开头和结尾
  - 开头 `^`
  - 结尾 `$`
- 指定范围 
  - `[...]`：只包含范围内字符
  - `[^...]`： 不包含范围内字符
- 规则匹配
  - 用`|`连接的两个正则规则是或规则
- 括号
  - 对于复杂规则，可以把公共部分提出来，然后用`(...)`把子规则括起来表示成`learn\\s(java|php|go)`

#### 4. 分组匹配

- 括号

  - `(...)`可以用来把一个子规则括起来
  - 实际上`(...)`还有一个重要作用，就是分组匹配，用来提取匹配的子串

- 使用

  - 必须引入`java.util.regex`包，用`Pattern`对象匹配，匹配后获得一个`Matcher`对象，如果匹配成功，就可以直接从`Matcher.group(index)`返回子串

  - ```java
    import java.util.regex.*;
    
    Pattern p = Pattern.compile("(\\d{3,4})\\-(\\d{7,8})");
    Matcher m = p.matcher("010-12345678");
    if (m.matches()) {
        String g1 = m.group(1); // 010
        String g2 = m.group(2); // 12345678
    }
    ```

  - 注意

    - `Matcher.group(index)`方法的参数用1表示第一个子串，2表示第二个子串
    - 传入0会得到整个正则匹配到的字符串

- 优势

  - `String.matches()`方法内部调用的就是`Pattern`和`Matcher`类的方法
  - 但是反复使用`String.matches()`对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的`Pattern`对象
  - 完全可以先创建出一个`Pattern`对象，然后反复使用，就可以实现编译一次，多次匹配

#### 5. 非贪婪匹配

- 贪婪匹配
  - 正则表达式默认使用贪婪匹配
  - 任何一个规则，它总是尽可能多地向后匹配
- 非贪婪匹配
  - 给定一个匹配规则，加上`?`后就变成了非贪婪匹配
- `?` 有两个作用
  - 修饰符`?`可以匹配0个或一个字符
  - 给定一个匹配规则，加上`?`后就变成了非贪婪匹配

#### 6. 操作字符串

- 分割

  - `String.split()`方法传入的正是正则表达式

- 搜索

  - 我们获取到`Matcher`对象后，不需要调用`matches()`方法（因为匹配整个串肯定返回false），而是反复调用`find()`方法，在整个串中搜索能匹配上`\\wo\\w`规则的子串，并打印出来

  - ```java
    String s = "the quick brown fox jumps over the lazy dog.";
    Pattern p = Pattern.compile("\\wo\\w");
    Matcher m = p.matcher(s);
    while (m.find())
        String sub = s.substring(m.start(), m.end());
    	// row, fox, dog
    ```

- 替换

  - 使用

    - 使用正则表达式替换字符串可以直接调用`String.replaceAll()`，它的第一个参数是正则表达式，第二个参数是待替换的字符串

    - ```java
      String s = "The     quick\t\t brown   fox  jumps   over the  lazy dog.";
      String r = s.replaceAll("\\s+", " "); 
      // The quick brown fox jumps over the lazy dog.
      ```

  - 反向引用
  
    - 使用`replaceAll()`的时候，我们传入的第二个参数可以使用`$1`、`$2`来反向引用匹配到的子串
  
    - ```java
      String s = "the quick brown fox jumps over the lazy dog.";
      String r = s.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
      // the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.
      ```



## 第十四章 Maven 基础

- Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具

#### 1. 简介

- 项目管理的问题

  - 依赖包的管理
  - 确定项目的目录结构
  - 配置环境
  - 能通过命令行工具进行编译

- 功能

  - 提供了一套标准化的项目结构
  - 提供了一套标准化的构建流程（编译，测试，打包，发布……）
  - 提供了一套依赖管理机制

- 项目描述文件

  - `pom.xml`

  - 名词解释

    - `groupId`类似于Java的包名，通常是公司或组织名称
    - `artifactId`类似于Java的类名，通常是项目名称
    - 再加上`version`
    - 一个Maven工程就是由`groupId`，`artifactId`和`version`作为唯一标识

  - ```xml
    <dependency>
        <groupId>commons-logging</groupId>
        <artifactId>commons-logging</artifactId>
        <version>1.2</version>
    </dependency>
    ```

#### 2. 依赖管理

- 依赖关系

  | scope    | 说明                                          | 示例            |
  | :------- | :-------------------------------------------- | :-------------- |
  | compile  | 编译时需要用到该jar包（默认）                 | commons-logging |
  | test     | 编译Test时需要用到该jar包                     | junit           |
  | runtime  | 编译时不需要，但运行时需要用到                | mysql           |
  | provided | 编译时需要用到，但运行时由JDK或某个服务器提供 | servlet-api     |

- 唯一ID

  - 对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包
    - groupId：属于组织的名称，类似Java的包名
    - artifactId：该jar包自身的名称，类似Java的类名
    - version：该jar包的版本
  - 特点
    - 任何一个jar包一经发布就无法修改，修改已发布jar包的唯一方法是发布一个新版本
    - 只有以`-SNAPSHOT`结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT

- Maven镜像

  - 如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库
  - Maven镜像仓库定期从中央仓库同步
  - 中国区用户可以使用阿里云提供的Maven镜像仓库

- 搜索第三方组件

  - 问题
    - 如果我们要引用一个第三方组件，比如`okhttp`，如何确切地获得它的`groupId`、`artifactId`和`version`？
  - 解决
    - 通过[search.maven.org](https://search.maven.org/)搜索关键字

- 命令行编译

  - 进入 pom.xml 所在目录

  - ```shell
    $ mvn clean package
    ```

  - 如果一切顺利，即可在`target`目录下获得编译后自动打包的jar

#### 3. 构建流程

- 简介

  - Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等
- Lifecycle 生命周期

  - Maven的生命周期由一系列阶段（phase）构成
  - 内置的生命周期`default`包含以下phase
    - validate
    - initialize
    - generate-sources
    - process-sources
    - generate-resources
    - process-resources
    - compile
    - process-classes
    - generate-test-sources
    - process-test-sources
    - generate-test-resources
    - process-test-resources
    - test-compile
    - process-test-classes
    - test
    - prepare-package
    - package
    - pre-integration-test
    - integration-test
    - post-integration-test
    - verify
    - install
    - deploy
  - Maven另一个常用的生命周期是`clean`，它会执行3个phase
    - pre-clean
    - clean （注意这个clean不是lifecycle而是phase）
    - post-clean
- 使用

  - 说明
  - 使用`mvn`这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase
    - 大多数phase在执行过程中，因为我们通常没有在`pom.xml`中配置相关的设置，所以这些phase什么事情都不做
- 举例
  
    - 运行`mvn package`，Maven就会执行`default`生命周期，它会从开始一直运行到`package`这个phase为止
    - 运行`mvn compile`，Maven也会执行`default`生命周期，但这次它只会运行到`compile`
  - 运行`mvn clean package`，Maven先执行`clean`生命周期并运行到`clean`这个phase，然后执行`default`生命周期并运行到`package`这个phase
  - 常用命令

    - `mvn clean`：清理所有生成的class和jar
- `mvn clean compile`：先清理，再执行到`compile`
    - `mvn clean test`：先清理，再执行到`test`，因为执行`test`前必须执行`compile`，所以这里不必指定`compile`
- `mvn clean package`：先清理，再执行到`package`
  - 常用 phase
  - clean：清理
    - compile：编译
    - test：运行测试
    - package：打包
- Goal
  - 执行一个phase又会触发一个或多个goal
  - goal的命名总是`abc:xyz`这种形式
- 总结
  - lifecycle相当于Java的package，它包含一个或多个phase
  - phase相当于Java的class，它包含一个或多个goal
  - goal相当于class的method，它其实才是真正干活的

#### 4. 使用插件

- 插件
  - 使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们
  - 如果标准插件无法满足需求，我们还可以使用自定义插件
  - Maven通过自定义插件可以执行项目构建时需要的额外功能，使用自定义插件必须在pom.xml中声明插件及配置
- 常用插件
  - maven-shade-plugin：打包所有依赖包并生成可执行jar
  - cobertura-maven-plugin：生成单元测试覆盖率报告
  - findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题

#### 5. 模块管理

- 简介

  - Maven支持模块化管理，可以把一个大项目拆成几个模块

  - ```
    multiple-project
    ├── pom.xml
    ├── parent
    │   └── pom.xml
    ├── module-a
    │   ├── pom.xml
    │   └── src
    ├── module-b
    │   ├── pom.xml
    │   └── src
    └── module-c
        ├── pom.xml
        └── src
    ```

- 引入模块

  - 中央仓库
  - 私有仓库
  - 本地仓库

#### 6. 使用mvnw

- 简介

  - Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用
  - Maven Wrapper的另一个作用是把项目的`mvnw`、`mvnw.cmd`和`.mvn`提交到版本库中，可以使所有开发人员使用统一的Maven版本

- 使用

  - 安装

    - 进入项目的根目录

    - ```shell
      mvn -N io.takari:maven:0.7.6:wrapper [-Dmaven=3.3.3]
      ```

    - `0.7.6`是Maven Wrapper的版本，而不是 Maven 版本

    - 如果不指定 Maven 版本（-Dmaven=3.3.3），则会自动使用最新版本的 Maven

  - 运行

    - 我们只需要把`mvn`命令改成`mvnw`就可以使用跟项目关联的Maven

#### 7. 发布Artifact

- 以静态文件发布
  - 发布到本地，然后由静态服务器提供repo服务，使用方必须声明repo地址
- 通过Nexus发布到中央仓库
  - 发布到[central.sonatype.org](https://central.sonatype.org/)，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置
- 发布到私有仓库
  - 发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用



## 第十六章 XML 与 JSON

- XML和JSON是两种经常在网络使用的数据表示格式

#### 1. XML 简介

- 简介

  - XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据

- 特点

  - 一是纯文本，默认使用UTF-8编码
  - 二是可嵌套，适合表示结构化数据

- 结构

  - ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE note SYSTEM "book.dtd">
    <book id="1">
        <name>Java核心技术</name>
        <author>Cay S. Horstmann</author>
        <isbn lang="CN">1234567</isbn>
        <tags>
            <tag>Java</tag>
            <tag>Network</tag>
        </tags>
        <pubDate/>
    </book>
    ```

  - 首行必定是`<?xml version="1.0"?>`，可以加上可选的编码

  - 如果以类似`<!DOCTYPE note SYSTEM "book.dtd">`声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的

  - 接下来是XML的文档内容

    - 一个XML文档有且仅有一个根元素
    - 根元素可以包含任意个子元素
    - 元素可以包含属性，例如，`<isbn lang="CN">1234567</isbn>`包含一个属性`lang="CN"`
    - 如果是空元素，可以用`<tag/>`表示

  - 特殊符号

    - 由于使用了`<`、`>`以及引号等标识符，如果内容出现了特殊符号，需要使用`&???;`表示转义

    | 字符 | 表示     | 英文                 | 中文 |
    | :--- | :------- | -------------------- | ---- |
    | <    | `&lt;`   | **l**ess **t**han    | 小于 |
    | >    | `&gt;`   | **g**reater **t**han | 大于 |
    | &    | `&amp;`  | **amp**ersand        | 和号 |
    | "    | `&quot;` | **quot**ation mark   | 引号 |
    | '    | `&apos;` | **apos**trophe       | 撇号 |

- 分类
  - 格式正确的XML（Well Formed）是指XML的格式是正确的，可以被解析器正常读取
  - 而合法的XML是指，不但XML格式正确，而且它的数据结构可以被DTD或者XSD验证
    - DTD文档可以指定一系列规则
- XML是一个技术体系，除了我们经常用到的XML文档本身外，XML还支持
  - DTD和XSD：验证XML结构和数据是否有效
  - Namespace：XML节点和属性的名字空间
  - XSLT：把XML转化为另一种文本
  - XPath：一种XML节点查询语言
  - 这些相关技术实现起来非常复杂，在实际应用中很少用到

#### 2. DOM

- 解析API
  - DOM：一次性读取XML，并在内存中表示为树形结构
  - SAX：以流的形式读取XML，使用事件回调
- DOM 模型
  - Document Object Model
  
  - 特点
  
    - 把XML结构作为一个树形结构处理，从根节点是 DOCUMENT_NODE，剩下的子节点都是 ELEMENT_NODE，每个节点都可以包含任意个子节点
    - 要读取某个节点的文本，需要访问它的 TEXT_NODE 类型的子节点
    - 最顶层的document代表XML文档，它是真正的“根”，而`<book>`虽然是根元素，但它是`document`的一个子节点
    - 解析速度慢，内存占用大
  
  - 创建
  
    - ```java
      InputStream input = Main.class.getResourceAsStream("/book.xml");
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
      DocumentBuilder db = dbf.newDocumentBuilder();
      // 可以接收 InputStream，File或者URL
      Document doc = db.parse(input);
      ```
  
  - 遍历
  
    - ```java
      void printNode(Node n) {
      for (Node child = n.getFirstChild(); child != null; child = child.getNextSibling())
          printNode(child);
      }
      ```

#### 3. SAX

- 简介
  - Simple API for XML
  - 基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据
  - 无论XML有多大，占用的内存都很小
- 使用
  - SAX解析会触发一系列事件：
    - startDocument：开始读取XML文档
    - startElement：读取到了一个元素，例如`<book>`
    - characters：读取到了字符
    - endElement：读取到了一个结束的元素，例如`</book>`
    - endDocument：读取XML文档结束
  - 关键代码`SAXParser.parse()`除了需要传入一个`InputStream`外，还需要传入一个回调对象，这个对象要继承自`DefaultHandler`
  - 仍然比较麻烦

#### 4. Jackson

- 使用Jackson解析XML，可以直接把XML解析为JavaBean，十分方便

#### 5. Json 简介

- 简介
  - JavaScript Object Notation
  - 去除了所有JavaScript执行代码，只保留JavaScript的对象格式
  - 轻量级的数据表示方式，常用于Web应用
- 优点
  - JSON只允许使用UTF-8编码，不存在编码问题
  - JSON只允许使用双引号作为key，特殊字符用`\`转义，格式简单
  - 浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理
- 数据类型
  - 键值对：`{"key": value}`
  - 数组：`[1, 2, 3]`
  - 字符串：`"abc"`
  - 数值（整数和浮点数）：`12.34`
  - 布尔值：`true`或`false`
  - 空值：`null`
- 解析
  - Jackson可以实现JavaBean和JSON之间的转换
  - 可以通过Module扩展Jackson能处理的数据类型
  - 可以自定义`JsonSerializer`和`JsonDeserializer`来定制序列化和反序列化



## 第十八章 函数式编程

- Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带`this`参数的函数
- 函数式编程最早是数学家[阿隆佐·邱奇](https://zh.wikipedia.org/wiki/阿隆佐·邱奇)研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算
- Java平台从Java 8开始，支持函数式编程

### 1. Lambda 基础

- 函数
  - 无论是实例方法，还是静态方法，本质上都相当于过程式语言的函数
  - 只不过Java的实例方法隐含地传入了一个`this`变量
  - 函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数

- Lambda 表达式
  - 单方法接口
    
    - 在Java程序中，我们经常遇到一大堆单方法接口，即一个接口只定义了一个方法，例如 Comparator，Runnable，Callable
    
    - 我们把只定义了单方法的接口称之为`FunctionalInterface`，用注解`@FunctionalInterface`标记
    
    - ```java
      Arrays.sort(array, new Comparator<String>() {
          public int compare(String s1, String s2) {
              return s1.compareTo(s2);
          }
      });
      ```
    
  - 从Java 8开始，我们可以用Lambda表达式替换单方法接口
  
    - ```java
      Arrays.sort(array, (s1, s2) -> {
          return s1.compareTo(s2);
      });
      ```
  
    - 只需要写出方法定义
  
    - 参数类型可以省略，因为编译器可以自动推断出`String`类型
  
    - `-> { ... }`表示方法体，如果只有一行 `return xxx `的代码则可以直接写成 `-> xxx `
  
    - 返回值的类型也是由编译器自动推断的

### 2. 方法引用

- 简介

  - 为了替换替换单方法接口，除了 Lambda 表达式，我们还可以直接传入方法引用
  - 所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用
  - 注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系

- 静态方法引用

  - ```java
    public class Main {
        public static void main(String[] args) {
            String[] array = new String[] {"Apple", "Orange", "Banana"};
            Arrays.sort(array, Main::cmp);
        }
    
        static int cmp(String s1, String s2) {
            return s1.compareTo(s2);
        }
    }
    ```

- 实例方法引用

  - ```java
    Arrays.sort(array, String::compareTo);
    ```

  - 注意，`String::compareTo` 的签名只有一个参数，这里之所以能匹配，是因为实例方法有一个隐含的`this`参数

  - ```java
    public final class String {
    	public int compareTo(String o) {...}
    }
    ```

- 构造方法引用

  - ```java
    List<String> names = List.of("Bob", "Alice", "Tim");
    List<Person> persons = names.stream().map(Person::new).collect(Collectors.toList());
    ```

  - 如果要把一个`List<String>`转换为`List<Person>`，传统的做法是先定义一个`ArrayList<Person>`，然后用`for`循环填充这个`List`

  - 要更简单地实现`String`到`Person`的转换，我们可以引用`Person`的构造方法，构造方法的引用写法是`类名::new`

  - 这里的`map()`需要传入的FunctionalInterface的定义是

    - ```java
      @FunctionalInterface
      public interface Function<T, R> {
          R apply(T t);
      }
      ```

    - 把泛型对应上就是方法签名`Person apply(String)`

### 3. Stream

- 简介
  
  - Java从8开始，不但引入了Lambda表达式，还引入了一个全新的流式API：Stream API。它位于`java.util.stream`包中
  
- 对比
  
  - 这个`Stream`不同于`java.io`的`InputStream`和`OutputStream`
  
    |      | java.io                  | java.util.stream           |
    | :--- | :----------------------- | -------------------------- |
    | 存储 | 顺序读写的`byte`或`char` | 顺序输出的任意Java对象实例 |
    | 用途 | 序列化至文件或网络       | 内存计算／业务逻辑         |
  
- 特点
  
  - 代表任意Java对象的序列
  - 输出的元素可能并没有预先存储在内存中，而是实时计算出来的
  - 一个`Stream`可以轻易地转换为另一个`Stream`，而不是修改原`Stream`本身
  - 一个`Stream`转换为另一个`Stream`时，实际上只存储了转换规则，并没有任何计算发生，真正的计算通常发生在最后结果的获取，也就是惰性计算
  
- 总结
  - Stream API提供了一套新的流式处理的抽象序列
  - Stream API支持函数式编程和链式操作
  - Stream可以表示无限序列，并且大多数情况下是惰性求值的

#### 1. 创建

- Stream.of()

  - 创建`Stream`最简单的方式是直接用`Stream.of()`静态方法，传入可变参数即创建了一个能输出确定元素的`Stream`

  - ```java
    Stream<String> stream = Stream.of("A", "B", "C", "D");
    ```

  - 虽然这种方式基本上没啥实质性用途，但测试的时候很方便

- 基于数组或Collection

  - 这样该`Stream`输出的元素就是数组或者`Collection`持有的元素

  - ```java
    // 数组
    Stream<String> stream1 = Arrays.stream(new String[] { "A", "B", "C" });
    // Collection（List、Set、Queue等）
    Stream<String> stream2 = List.of("X", "Y", "Z").stream();
    ```

  - 把一个现有的序列变为`Stream`，它的元素是固定的

- 基于Supplier

  - 创建`Stream`还可以通过`Stream.generate()`方法，它需要传入一个`Supplier`对象

  - ```java
    Stream<Integer> s = Stream.generate(new NatualSupplier());
    
    class NatualSupplier implements Supplier<Integer> {
        int n = 0;
        public Integer get() {
            n++;
            return n;
        }
    }
    ```

  - 特点

    - 基于`Supplier`创建的`Stream`会不断调用`Supplier.get()`方法来不断产生下一个元素
    - 这种`Stream`保存的不是元素，而是算法，它可以用来表示无限序列

  - 注意

    - 对于无限序列，如果直接调用`forEach()`或者`count()`这些最终求值操作，会进入死循环
    - 所以正确的方法是先把无限序列变成有限序列，例如，用`limit()`方法可以截取前面若干个元素

- 其他方法

  - 通过一些API提供的接口，直接获得`Stream`

  - lines()

    - `Files`类的`lines()`方法可以把一个文件变成一个`Stream`，每个元素代表文件的一行内容

    - ```java
      Stream<String> lines = Files.lines(Paths.get("/path/to/file.txt"))
      ```

  - splitAsStream()

    - 正则表达式的`Pattern`对象有一个`splitAsStream()`方法，可以直接把一个长字符串分割成`Stream`序列而不是数组

    - ```java
      Pattern p = Pattern.compile("\\s+");
      Stream<String> s = p.splitAsStream("The quick brown fox jumps over the lazy dog");
      ```

- 基本类型
  - 问题
    - 因为Java的范型不支持基本类型，所以我们无法用`Stream<int>`这样的类型
    - 为了保存`int`，只能使用`Stream<Integer>`，但这样会产生频繁的装箱、拆箱操作，影响效率
  - 解决
    - 为了提高效率，Java标准库提供了`IntStream`、`LongStream`和`DoubleStream`这三种使用基本类型的`Stream`

#### 2. 使用 map

- 简介

  - 把一种操作运算，映射到一个序列的每一个元素上

  - ```java
    Stream<Integer> s = Stream.of(1, 2, 3, 4, 5).map(n -> n * n);
    ```

- 分析

  - `map()`方法接收的对象是`Function`接口对象

    - ```java
      <R> Stream<R> map(Function<? super T, ? extends R> mapper);
      ```

  - `Function`接口对象定义了一个`apply()`方法，负责把一个`T`类型转换成`R`类型

    - ```java
      @FunctionalInterface
      public interface Function<T, R> {
          // 将T类型转换为R:
          R apply(T t);
      }
      ```

#### 3. 使用 filter

- 简介

  - 对一个`Stream`的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的`Stream`

  - ```java
    IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
        .filter(n -> n % 2 != 0)
        .forEach(System.out::println); // 1, 3, 5, 7, 9
    ```

- 分析

  - `filter()`方法接收的对象是`Predicate`接口对象，它定义了一个`test()`方法，负责判断元素是否符合条件

    - ```java
      @FunctionalInterface
      public interface Predicate<T> {
          // 判断元素t是否符合条件:
          boolean test(T t);
      }
      ```

#### 4. 使用 reduce

- 简介

  - `map()`和`filter()`都是`Stream`的转换方法，而`Stream.reduce()`则是`Stream`的一个聚合方法，它可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果
  - 聚合方法会立刻对`Stream`进行计算

- 分析

  - `reduce()`方法传入的对象是`BinaryOperator`接口，它定义了一个`apply()`方法，负责把上次累加的结果和本次的元素进行运算，并返回累加的结果

  - ```java
    @FunctionalInterface
    public interface BinaryOperator<T> {
        // Bi操作：两个输入，一个输出
        T apply(T t, T u);
    }
    ```

- 举例

  - 求和

    - ```java
      int sum = Stream.of(1, 2, 3).reduce(0, (acc, n) -> acc + n); // 6
      ```

  - 求积

    - ```java
      int s = Stream.of(1, 2, 3).reduce(1, (acc, n) -> acc * n); // 6
      ```

- 去掉初始值

  - 如果去掉初始值，我们会得到一个`Optional<Integer>`

  - ```java
    Optional<Integer> opt = stream.reduce((acc, n) -> acc + n);
    if (opt.isPresent) {
        System.out.println(opt.get());
    }
    ```

  - 这是因为`Stream`的元素有可能是0个，这样就没法调用`reduce()`的聚合函数了，因此返回`Optional`对象，需要进一步判断结果是否存在

#### 5. 输出集合

- 操作分类

  - 转换操作
    - 把一个`Stream`转换为另一个`Stream`
    - 对 Stream 进行转换操作并不会触发任何计算
  - 聚合操作
    - 对`Stream`的每个元素进行计算，得到一个确定的其他的Java对象
    - 对一个`Stream`进行聚合操作，会触发真正的计算

- 输出为List

  - 因为`List`的元素是确定的Java对象，因此，把`Stream`变为`List`不是一个转换操作，而是一个聚合操作，它会强制`Stream`输出每个元素

  - ```java
    List<String> list = stream.collect(Collectors.toList());
    // 类似的，collect(Collectors.toSet()) 将 Stream 转化为 set
    ```

  - 调用`collect()`并传入`Collectors.toList()`对象，它实际上是一个`Collector`实例，通过类似`reduce()`的操作，把每个元素添加到一个收集器中（实际上是`ArrayList`）

- 输出为数组

  - ```java
    String[] array = stream.toArray(String[]::new);
    ```

  - 注意到传入的“构造方法”是`String[]::new`，它的签名实际上是`IntFunction<String[]>`定义的`String[] apply(int)`，即传入`int`参数，获得`String[]`数组的返回值

- 输出为Map

  - 对于每个元素，添加到Map时需要key和value，因此，我们要指定两个映射函数，分别把元素映射为key和value

  - ```java
    Stream<String> stream = Stream.of("APPL:Apple", "MSFT:Microsoft");
    Map<String, String> map = stream
        .collect(
        	Collectors.toMap(
                // 把元素s映射为key:
                s -> s.substring(0, s.indexOf(':')),
                // 把元素s映射为value:
                s -> s.substring(s.indexOf(':') + 1)
        	)
        );
    ```

- 分组输出

  - ```java
    List<String> list = List.of("Apple", "Banana", "Blackberry", "Coconut", "Avocado", "Cherry", "Apricots");
    Map<String, List<String>> groups = list.stream()
        .collect(
        	Collectors.groupingBy(
                s -> s.substring(0, 1), Collectors.toList()
            )
    	);
    ```

  - 分组输出使用`Collectors.groupingBy()`，它需要提供两个函数

    - 一个是分组的key，这里使用`s -> s.substring(0, 1)`，表示只要首字母相同的`String`分到一组
    - 第二个是分组的value，这里直接使用`Collectors.toList()`，表示输出为`List`

#### 6. 其他操作

- 转换操作

  - 排序

    - ```java
      sorted()
      ```

    - 此方法要求`Stream`的每个元素必须实现`Comparable`接口

    - 如果要自定义排序，传入指定的`Comparator`即可

  - 去重

    - ```java
      distinct()
      ```

  - 截取

    - ```java
      skip(2)
      limit(3)
      ```

    - `skip()`用于跳过当前`Stream`的前N个元素

    - `limit()`用于截取当前`Stream`最多前N个元素

  - 合并

    - ```java
      Stream<String> s = Stream.concat(s1, s2);
      ```

    - `Stream`的静态方法`concat()`

  - flatMap

    - ```java
      Stream<List<Integer>> s = Stream.of(
              Arrays.asList(1, 2, 3),
              Arrays.asList(4, 5, 6),
              Arrays.asList(7, 8, 9));
      Stream<Integer> i = s.flatMap(list -> list.stream());
      // 1, 2, 3, 4, 5, 6, 7, 8, 9
      ```

    - 把`Stream`的每个元素（这里是`List`）映射为`Stream`，然后合并成一个新的`Stream`

  - 并行

    - ```java
      parallel()
      ```

    - 经过`parallel()`转换后的`Stream`只要可能，就会对后续操作进行并行处理。我们不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升

- 聚合方法

  - 使用于所有 Stream
    - `count()`：用于返回元素个数
    - `max(Comparator<? super T> cp)`：找出最大元素
    - `min(Comparator<? super T> cp)`：找出最小元素
    - `boolean allMatch(Predicate<? super T>)`：测试是否所有元素均满足测试条件
    - `boolean anyMatch(Predicate<? super T>)`：测试是否至少有一个元素满足测试条件
    - `forEach()`：循环处理`Stream`的每个元素
  - 针对`IntStream`、`LongStream`和`DoubleStream`
    - `sum()`：对所有元素求和
    - `average()`：对所有元素求平均数