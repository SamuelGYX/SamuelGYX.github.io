---
layout: post
title:  【廖雪峰】Java教程 II
date:   2020-07-16
categories: Java
---



## 第三章 异常处理

#### 1. Java 的异常

- 发展
  - 所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错
  - 调用方如何获知调用失败的信息？有两种方法
    - 方法一：约定返回错误码
      - 常见于底层C函数
    - 方法二：在语言层面上提供一个异常处理机制
- 定义
  - Java的异常是`class`，`Throwable`是异常体系的根，它继承自`Object`
- 分类
  - `Error`：表示严重的错误，程序对此一般无能为力
  - `Exception`：运行时的错误，它可以被捕获并处理
    - `RuntimeException`
    - 非 `RuntimeException` 
- 分类 2
  - 必须捕获的异常
    - 包括`Exception`及其子类，但不包括`RuntimeException`及其子类，这种类型的异常称为Checked Exception
    - 如果程序中没有捕获语句则会出现编译失败
  - 不需要捕获的异常
    - 包括`Error`及其子类，`RuntimeException`及其子类
    - 编译器不做强制要求，但是是否需要捕获需要具体分析
- 捕获异常
  - 在方法定义的时候，使用`throws Xxx`表示该方法可能抛出的异常类型
  - 只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获，或者抛出

#### 2. 捕获异常

- catch 语句
  - 可以使用多个`catch`语句，每个`catch`分别捕获对应的`Exception`及其子类
  - 匹配到某个`catch`后，执行`catch`代码块，然后不再继续匹配
  - 因此，存在多个`catch`的时候，`catch`的顺序非常重要，子类必须写在前面
- finally 语句
  - `finally`语句块保证有无错误都会执行
  - 特点
    - `finally`语句不是必须的，可写可不写
    - `finally`总是最后执行
  - 某些情况下，可以没有`catch`，只使用`try ... finally`结构
- 捕获多种异常
  - 如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条`catch`子句
  - 我们可以把多个异常类型用`|`合并到一起

#### 3. 抛出异常

- 异常的传播
  - 通过`printStackTrace()`可以打印出方法的调用栈
- 抛出异常
  - 创建某个`Exception`的实例
  - 用`throw`语句抛出
- 异常的转换
  - 定义
    - 如果一个方法捕获了某个异常后，又在`catch`子句中抛出新的异常，就相当于把抛出的异常类型“转换”了
  - 注意
    - 新的异常丢失了原始异常信息
    - 为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息
  - 查看
    - 在代码中获取原始异常可以使用`Throwable.getCause()`方法。如果返回`null`，说明已经是“根异常”了
- finally 的执行顺序
  - 在同一个代码块中，throw 之后的语句都不会被执行
  - 但是，在 finally 中的语句除外，程序总会执行完 finally 之后才抛出异常
- 异常屏蔽
  - 定义
    - 如果在 finally 中有抛出异常，则原来在 catch 中准备抛出的异常就“消失”了
    - 没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）
  - 处理方法
    - 如果要保存被屏蔽的异常，需要先用变量保存原始异常，然后调用`Throwable.addSuppressed()`，把原始异常添加进来
    - 通过`Throwable.getSuppressed()`可以获取所有的`Suppressed Exception`
  - 注意
    - 因此，绝大多数情况下，在`finally`中不要抛出异常

#### 4. 自定义异常

- 抛出异常时，尽量复用JDK已定义的异常类型
- 自定义异常体系时，推荐从`RuntimeException`派生“根异常”，再派生出业务异常
- 自定义异常时，应该提供多种构造方法

#### 5. NullPointerException

- 定义
  - 如果一个对象为`null`，调用其方法或访问其字段就会产生`NullPointerException`
  - 属于 `RuntimeException`
- 处理
  - `NullPointerException`是Java代码常见的逻辑错误，应当早暴露，早修复
  - 可以启用Java 14的增强异常信息来查看`NullPointerException`的详细错误信息

#### 6. 断言

- 定义

  - 断言（Assertion）是一种调试程序的方式，在Java中，使用`assert`关键字来实现断言

  - 断言成功，则程序正常运行，断言失败，抛出`AssertionError`

  - ```java
    assert x >= 0 : "x must >= 0";
    ```

- 使用
  - 断言失败时会抛出`AssertionError`，导致程序结束退出
  - 因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段
  - 对于可恢复的程序错误，不应该使用断言
- 注意
  - 要执行`assert`语句，必须给Java虚拟机传递`-enableassertions`（可简写为`-ea`）参数启用断言
  - 实际开发中，很少使用断言，更好的方法是编写单元测试 `JUnit`

#### 7. JDK Logging

- 定义

  - 日志就是Logging，它的目的是为了取代`System.out.println()`

- 优势

  - 可以设置输出样式，自动打印时间、调用类、调用方法等很多有用的信息
  - 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志
  - 可以被重定向到文件，这样可以在程序运行结束后查看日志
  - 可以按包名控制日志级别，只输出某些包打的日志

- 使用

  - Java标准库内置了日志包`java.util.logging`

  - ```java
    Logger logger = Logger.getGlobal();
    logger.info("start process...");
    logger.warning("memory is running out...");
    ```

  - 7 个日志级别

    - SEVERE
    - WARNING
    - INFO
    - CONFIG
    - FINE
    - FINER
    - FINEST

  - 默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来

- 问题

  - Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行`main()`方法，就无法修改配置
  - 配置不太方便，需要在JVM启动时传递参数`-Djava.util.logging.config.file=<config-file-name>`

#### 8. Commons Logging

- 简介

  - Commons Logging是一个第三方日志库，它是由Apache创建的日志模块
  - 是使用最广泛的日志模块，API 简单，还可以自动检测并使用其他日志模块
  - 特色是可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统
  - 默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging

- 通用使用

  - 第一步，通过`LogFactory`获取`Log`类的实例

  - 第二步，使用`Log`实例的方法打日志

  - ```java
    Log log = LogFactory.getLog(Main.class);
    log.info("start...");
    log.warn("end.");
    ```

  - 6 个日志级别，默认级别是`INFO`

    - FATAL
    - ERROR
    - WARNING
    - INFO
    - DEBUG
    - TRACE

  - Commons Logging的日志方法，例如`info()`，除了标准的`info(String)`外，还提供了一个非常有用的重载方法：`info(String, Throwable)`，这使得记录异常更加简单

- 使用

  - 静态方法

    - 通常直接定义一个静态类型变量

    - ```java
      static final Log log = LogFactory.getLog(Main.class);
      ```

  - 实例方法

    - 通常定义一个实例变量

    - ```java
      protected final Log log = LogFactory.getLog(getClass());
      ```

    - 注意：可以使用 `<Class-Name>.class` 代替 `getClass()`， 但这种写法的好处在于，子类可以直接使用该`log`实例，无需改动代码

#### 9. Log4j

- 简介
  - 前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j
- 构件
  - Appender
    - 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地
  - Filter
    - 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出
  - Layout
    - 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息
  - 目的地
    - console：输出到屏幕
    - file：输出到文件
    - socket：通过网络输出到远程计算机
    - jdbc：输出到数据库
- 使用
  - 配置文件
    - 把一个`log4j2.xml`的文件放到`classpath`下就可以让Log4j读取配置文件并按照我们的配置来输出日志
  - 依赖包
  - 调用 Commons Logging
    - 因为Commons Logging会自动发现并使用Log4j，所以要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出
- 编程规范
  - 在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j
  - 如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入`classpath`，就可以自动把日志切换成使用Log4j写入，无需修改任何代码

#### 10. SLF4J 和 Logback

- 简介
  - SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现
  - Java有着非常悠久的开源历史，开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库
  - 因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback



## 第七章 集合

#### 1. 简介

- Collection
  - Java标准库自带的`java.util`包提供了集合类：`Collection`，它是除`Map`外所有其他集合类的根接口
- 集合类型
  - List
    - 有序列表的集合
  - Set
    - 保证没有重复元素的集合
  - Map
    - 通过键值（key-value）查找的映射表集合
- 特点
  - 实现了接口和实现类相分离，例如，有序表的接口是`List`，具体的实现类有`ArrayList`，`LinkedList`等
  - 支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素
  - Java访问集合总是通过统一的方式——迭代器（Iterator）来实现
- 历史遗留
  - Hashtable：一种线程安全的`Map`实现
  - Vector：一种线程安全的`List`实现
  - Stack：基于`Vector`实现的`LIFO`的栈
  - Enumeration<E> 接口：已被`Iterator<E>`取代

#### 2. List

- 简介

  - 在集合类中，`List`是最基础的一种集合：它是一种有序列表
  - `List`的行为和数组几乎完全相同，但封装了很多操作链表

- 接口方法

  - 在末尾添加一个元素：`boolean add(E e)`
  - 在指定索引添加一个元素：`boolean add(int index, E e)`
  - 删除指定索引的元素：`int remove(int index)`
  - 删除某个元素：`int remove(Object e)`
  - 获取指定索引的元素：`E get(int index)`
  - 获取链表大小（包含元素的个数）：`int size()`

- 实现方式

  - `ArrayList`：数组
  - `LinkedList`：链表
  - 通常情况下，我们总是优先使用`ArrayList`

- 常用操作

  - 创建

    - ```java
      List<String> list = new ArrayList<>();
      List<Integer> list = List.of(1, 2, 5);
      ```

  - 遍历

    - ```java
      for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
          String s = it.next();
          System.out.println(s);
      }
      // 只要实现了Iterable接口的集合类都可以直接用for each循环来遍历
      for (String s : list) {
          System.out.println(s);
      }
      ```

  - 转换

    - ```java
      // List to Array
      Object[] array = list.toArray(); // 丢失类型信息，所以实际应用很少
      Integer[] array = list.toArray(new Integer[list.size()]);
      Integer[] array = list.toArray(Integer[]::new);
      ```

    - ```java
      List<Integer> list = List.of(array); // 返回的是一个只读List
      List<Integer> list = Arrays.asList(array);
      ```

#### 3. List：equals 方法

- 需求
  - 在`List`中查找元素时，`List`的实现类通过元素的`equals()`方法比较两个元素是否相等，因此，放入的元素必须正确覆写`equals()`方法
- 方法要求
  - 自反性（Reflexive）
  - 对称性（Symmetric）
  - 传递性（Transitive）
  - 一致性（Consistent）
  - 对`null`的比较
- 编写方法
  - 先确定实例“相等”的逻辑
  - 用`instanceof`判断传入的待比较的`Object`是不是当前类型
  - 对引用类型用`Objects.equals()`比较，对基本类型直接用`==`比较
- 补充
  - 使用`Objects.equals()`比较两个引用类型是否相等的目的是省去了判断`null`的麻烦
  - 如果不调用`List`的`contains()`、`indexOf()`这些方法，那么放入的元素就不需要实现`equals()`方法

#### 4. Map

- 简介

  - `Map<K, V>`是一种键-值映射表
  - 和`List`类似，`Map`也是一个接口，最常用的实现类是`HashMap`

- 常用方法

  - 创建

    - ```java
      Map<String, Integer> map = new HashMap<>();
      ```

  - 存储

    - ```java
      map.put("apple", 123);
      ```

    - Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉

  - 获取

    - ```java
      Integer i = map.get("pear")
      ```

    - 如果`key`不存在，则返回`null`

  - 查找

    - ```java
      boolean containsKey(K key)
      ```

  - 遍历

    - ```java
      for (String key : map.keySet())
          Integer value = map.get(key);
      for (Map.Entry<String, Integer> entry : map.entrySet()) {
          String key = entry.getKey();
          Integer value = entry.getValue();
      }
      ```

    - 注意：Map 的遍历不保证顺序

#### 5. Map：equals 和 hashCode

- 正确使用`Map`必须保证

  - 作为`key`的对象必须正确覆写`equals()`方法
  - 作为`key`的对象还必须正确覆写`hashCode()`方法
    - 如果两个对象相等，则两个对象的`hashCode()`必须相等
    - 如果两个对象不相等，则两个对象的`hashCode()`尽量不要相等
  - 补充：对于放入`HashMap`的`value`对象，没有任何要求

- equals 和 hashCode 编写原则

  - `equals()`用到的用于比较的每一个字段，都必须在`hashCode()`中用于计算
  - `equals()`中没有使用到的字段，绝不能放在`hashCode()`中计算

- 实现

  - 实现`hashCode()`方法可以通过`Objects.hashCode()`辅助方法实现

  - ```java
    @Override
    int hashCode() {
        return Objects.hash(firstName, lastName, age);
    }
    ```

- 内部原理

  - `HashMap`初始化时默认的数组大小只有16

  - 添加超过一定数量的`key-value`时，`HashMap`会在内部自动扩容，每次扩容一倍

    - 频繁扩容对`HashMap`的性能影响很大，更好的方式是创建`HashMap`时就指定容量

    - ```java
      Map<String, Integer> map = new HashMap<>(10000);
      // 虽然指定容量是10000，但HashMap内部的数组长度总是2^n，因此，实际数组长度被初始化为比10000大的16384（2^14）
      ```

  - 在哈希冲突的时候，一种最简单的解决办法是用`List`存储`hashCode()`相同的`key-value`

#### 6. Map：EnumMap

- 简介

  - 如果作为key的对象是`enum`类型，那么，还可以使用Java集合库提供的一种`EnumMap`
  - 它在内部以一个非常紧凑的数组存储value，并且根据`enum`类型的key直接定位到内部数组的索引，并不需要计算`hashCode()`，不但效率最高，而且没有额外的空间浪费

- ```java
  Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);
  ```

#### 7. Map：TreeMap

- SortedMap

  - `HashMap`是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的
  - 还有一种`Map`，它在内部会对Key进行排序，这种`Map`就是`SortedMap`。注意到`SortedMap`是接口，它的实现类是`TreeMap`

- 特点

  - `SortedMap`保证遍历时以Key的顺序来进行排

- 注意

  - 使用`TreeMap`时，放入的Key必须实现`Comparable`接口，作为Value的对象则没有任何要求

  - 如果作为Key的class没有实现`Comparable`接口，那么，必须在创建`TreeMap`时同时指定一个自定义比较算法

    - ```java
      Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {
          public int compare(Person p1, Person p2) {
              return p1.name.compareTo(p2.name);
          }
      });
      ```

  - `TreeMap`不使用`equals()`和`hashCode()`

  - `TreeMap`在比较两个Key是否相等时，依赖Key的`compareTo()`方法或者`Comparator.compare()`方法。在两个Key相等时，必须返回`0`

#### 8. Map：Properties

- 简介

  - Java集合库提供的`Properties`用于读写配置文件`.properties`
  - `Properties`内部本质上是一个`Hashtable`，但我们只需要用到`Properties`自身关于读写配置的接口

- 读取

  - 步骤

    - 创建`Properties`实例
    - 调用`load()`读取文件
    - 调用`getProperty()`获取配置

  - 举例

    - ```java
      Properties props = new Properties();
    
      String f = "setting.properties";
      props.load(new java.io.FileInputStream(f));
    
      String filepath = props.getProperty("last_open_file");
      String interval = props.getProperty("auto_save_interval", "120");
      ```

  - 补充

    - `load(InputStream)` 方法接收一个`InputStream`实例，表示一个字节流

    - ```java
      // 文件流
      props.load(new java.io.FileInputStream("setting.properties"));
      // 从jar包中读取的资源流
      props.load(getClass().getResourceAsStream("/common/setting.properties"));
      // 从内存读取一个字节流
      String settings = "# test" + "\n" + "course=Java";
      props.load(new ByteArrayInputStream(settings.getBytes("UTF-8")));
      ```

    - 如果有多个`.properties`文件，可以反复调用`load()`读取，后读取的key-value会覆盖已读取的key-value

    - 可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置

- 问题

  - 除了`getProperty()`和`setProperty()`方法外，还有从`Hashtable`继承下来的`get()`和`put()`方法
  - 我们在使用`Properties`的时候，不要去调用这些从`Hashtable`继承下来的方法

- 写入

  - store()

  - ```java
    props.setProperty("url", "http://www.liaoxuefeng.com");
    props.setProperty("language", "Java");
    props.store(new FileOutputStream("C:\\conf\\setting.properties"), "这是写入的properties注释");
    ```

- 编码

  - 早期版本的Java规定`.properties`文件编码是ASCII编码（ISO8859-1）

  - 从JDK9开始，Java的`.properties`文件可以使用UTF-8编码

  - 由于`load(InputStream)`默认总是以ASCII编码读取字节流，我们需要用另一个重载方法`load(Reader)`读取

  - ```java
    props.load(new FileReader("settings.properties", StandardCharsets.UTF_8));
    ```

  - `InputStream`和`Reader`的区别是一个是字节流，一个是字符流。字符流在内存中已经以`char`类型表示了，不涉及编码问题

#### 9. Set

- 简介
  - `Set`用于存储不重复的元素集合
  - `Set`实际上相当于只存储key、不存储value的`Map`
  - 最常用的`Set`实现类是`HashSet`，实际上，`HashSet`仅仅是对`HashMap`的一个简单封装
- 常用方法
  - 添加
    - `boolean add(E e)`
    - 元素已存在则添加失败，返回 false
  - 删除
    - `boolean remove(Object e)`
    - 元素不存在则删除失败，返回 false
  - 查询
    - `boolean contains(Object e)`
- 注意
  - 放入`Set`的元素和`Map`的key类似，都要正确实现`equals()`和`hashCode()`方法
  - `Set`接口并不保证有序
- 分类
  - 与 Map 非常类似
  - Set 接口
    - HashSet 实现：无序
    - SortedSet 接口
      - TreeSet 实现：有序
- TreeSet
  - 使用`TreeSet`和使用`TreeMap`的要求一样，添加的元素必须正确实现`Comparable`接口，如果没有实现`Comparable`接口，那么创建`TreeSet`时必须传入一个`Comparator`对象

#### 10. Queue

- 简介

  - `Queue`实际上是实现了一个先进先出（FIFO：First In First Out）的有序表

- 操作

  - 把元素添加到队列末尾
  - 从队列头部取出元素

- 常用方法

  - `int size()`
    - 获取队列长度
  - `boolean add(E)`/`boolean offer(E)`
    - 添加元素到队尾
  - `E remove()`/`E poll()`
    - 获取队首元素并从队列中删除
  - `E element()`/`E peek()`
    - 获取队首元素但并不从队列中删除

- 补充

  - 对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有

  - 注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的

    |                    | throw Exception | 返回false或null    |
    | :----------------- | :-------------- | ------------------ |
    | 添加元素到队尾     | add(E e)        | boolean offer(E e) |
    | 取队首元素并删除   | E remove()      | E poll()           |
    | 取队首元素但不删除 | E element()     | E peek()           |

  - 不要把`null`添加到队列中，否则`poll()`方法返回`null`时，很难确定是取到了`null`元素还是队列为空

- 面向抽象编程

  - `LinkedList`即实现了`List`接口，又实现了`Queue`接口

  - 在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用

  - ```java
    List<String> list = new LinkedList<>();
    Queue<String> queue = new LinkedList<>();
    ```

#### 11. Queue: PriorityQueue

- 简介

  - `PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关

- 注意

  - 放入`PriorityQueue`的元素，必须实现`Comparable`接口，或者提供一个`Comparator`对象，`PriorityQueue`会根据元素的排序顺序决定出队的优先级

  - ```java
    Queue<User> q = new PriorityQueue<>(new UserComparator());
    
    class UserComparator implements Comparator<User> {
        public int compare(User u1, User u2) {
            return Objects.compare(u1.name, u2.name)
        }
    }
    ```

#### 12. Queue：Deque

- 简介

  - `Queue`是队列，只能一头进，另一头出
  - 如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名`Deque`
  - `Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`

- 对比

  |                    | Queue                  | Deque                           |
  | :----------------- | :--------------------- | :------------------------------ |
  | 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |
  | 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |
  | 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |
  | 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |
  | 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |
  | 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |
  - `Deque`接口实际上扩展自`Queue`
  - 因此，`Queue`提供的`add()`/`offer()`方法在`Deque`中也可以使用，但是，使用`Deque`，最好不要调用`offer()`，而是调用`offerLast()`

- 面向抽象

  - 我们发现`LinkedList`真是一个全能选手，它即是`List`，又是`Queue`，还是`Deque`

  - 但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途

  - ```java
    // 不推荐的写法:
    LinkedList<String> d1 = new LinkedList<>();
    d1.offerLast("z");
    // 推荐的写法：
    Deque<String> d2 = new LinkedList<>();
    d2.offerLast("z");
    ```

  - 可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类

#### 13. Stack

- 简介
  - 栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构
- 操作
  - 把元素压栈：`push(E)`
  - 把栈顶的元素“弹出”：`pop(E)`
  - 取栈顶元素但不弹出：`peek(E)`
- 实现：`Deque`
  - 把元素压栈：`push(E)`/`addFirst(E)`；
  - 把栈顶的元素“弹出”：`pop(E)`/`removeFirst()`；
  - 取栈顶元素但不弹出：`peek(E)`/`peekFirst()`
- 补充
  - 为什么Java的集合类没有单独的`Stack`接口呢？因为有个遗留类名字就叫`Stack`，出于兼容性考虑，所以没办法创建`Stack`接口，只能用`Deque`接口来“模拟”一个`Stack`了
  - 当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰
- 作用
  - 对整数进行进制的转换
  - 计算中缀表达式

#### 14. Iterator

- 迭代器
  - Java的集合类都可以使用`for each`循环
  - 我们把这种通过`Iterator`对象遍历集合的模式称为迭代器
- 优势
  - 调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构
- 实现
  - 集合类实现`Iterable`接口，该接口要求返回一个`Iterator`对象
  - 用`Iterator`对象迭代集合内部数据

#### 15. Collections

- 简介
  - Collections，而不是 Collection

`Collections`是JDK提供的工具类，同样位于`java.util`包中。它提供了一系列静态方法，能更方便地操作各种集合

- 创建空集合

  - 方法

    - 创建空List：`List<T> emptyList()`
    - 创建空Map：`Map<K, V> emptyMap()`
    - 创建空Set：`Set<T> emptySet()`

  - 注意

    - 返回的空集合是不可变集合，无法向其中添加或删除元素

  - 补充

    - 也可以用各个集合接口提供的`of(T...)`方法创建空集合，完全等价

    - ```java
      List<String> list1 = List.of();
      List<String> list2 = Collections.emptyList();
      ```

- 创建单元素集合

  - 方法
    - 创建一个元素的List：`List<T> singletonList(T o)`
    - 创建一个元素的Map：`Map<K, V> singletonMap(K key, V value)`
    - 创建一个元素的Set：`Set<T> singleton(T o)`
  - 注意
    - 返回的单元素集合也是不可变集合，无法向其中添加或删除元素
  - 补充
    - 也可以用各个集合接口提供的`of(T...)`方法创建单元素集合
    - 实际上，使用`List.of(T...)`更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合

- 排序

  - 因为排序会直接修改`List`元素的位置，因此必须传入可变`List`

  - ```java
    Collections.sort(list);
    ```

- 洗牌

  - ```java
    Collections.shuffle(list);
    ```

- 不可变集合

  - `Collections`还提供了一组方法把可变集合封装成不可变集合
    - 封装成不可变List：`List<T> unmodifiableList(List<? extends T> list)`
    - 封装成不可变Set：`Set<T> unmodifiableSet(Set<? extends T> set)`
    - 封装成不可变Map：`Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)`
  - 注意
    - 这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的
    - 因此，返回不可变`List`后，最好立刻扔掉可变`List`的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”`List`变化了

- 线程安全集合

  - `Collections`还提供了一组方法，可以把线程不安全的集合变为线程安全的集合
    - 变为线程安全的List：`List<T> synchronizedList(List<T> list)`
    - 变为线程安全的Set：`Set<T> synchronizedSet(Set<T> s)`
    - 变为线程安全的Map：`Map<K,V> synchronizedMap(Map<K,V> m)`
  - 从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了



## 第十一章 正则表达式

#### 1. 简介

- 简介
  - 正则表达式可以用字符串来描述规则，并用来匹配字符串
  - Java标准库的`java.util.regex`包内置了正则表达式引擎
- 优势
  - 只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则
  - 正则表达式是一套标准，它可以用于任何语言

#### 2. 匹配规则

- 精确匹配
  - 普通字符
    - `abc` 只能精确匹配 `abc`
  - 特殊字符
    - 用`\`转义，例如 `\&`
  - 非ASCII字符
    - 用`\u####`的十六进制表示
- 模糊匹配
  - 单个任意字符 `.`
    - 用`.`匹配一个任意字符且仅限一个字符
  - 单个数字 `\d`
    - 如果我们只想匹配`0`~`9`这样的数字，可以用`\d`匹配，且仅限单个数字字符
    - 相当于 `[0-9]`
  - 单个常用字符 `\w`
    - 用`\w`可以匹配一个字母、数字或下划线，w的意思是word
    - 相当于 `[A-Za-z0-9_]`
  - 单个空格字符 `\s`
    - 用`\s`可以匹配一个空格字符
    - 注意空格字符不但包括空格` `，还包括tab字符（在Java中用`\t`表示）
  - 反义
    - 用`\d`可以匹配一个数字，而`\D`则匹配一个非数字
    - 类似的，`\W`可以匹配`\w`不能匹配的字符，`\S`可以匹配`\s`不能匹配的字符
  - 重复匹配
    - 修饰符`*`可以匹配任意个字符，包括0个字符
    - 修饰符`+`可以匹配至少一个字符
    - 修饰符`?`可以匹配0个或一个字符
    - 修饰符`{n}`可以精确匹配n个字符
    - 修饰符`{n,m}`可以匹配n~m个字符
    - 修饰符`{n,}`可以匹配至少n个字符
- 字符分类
  - 数字 `\d`
    - `0`, `1`, `2`, ..., `9`
  - 字母
    - `a`, `b`, `c`, ..., `X`, `Y`, `Z`
  - 下划线
    - `_`
  - Unicode 字符
    - `\u548c`, ...
  - 空字符 `\s`
    - ` `, `\t`
  - 其他符号
    - `&`, `@`, `#`, `-`, ...
    - 需要在符号前加 `\`

#### 3. 复杂匹配规则

- 开头和结尾
  - 开头 `^`
  - 结尾 `$`
- 指定范围 
  - `[...]`：只包含范围内字符
  - `[^...]`： 不包含范围内字符
- 规则匹配
  - 用`|`连接的两个正则规则是或规则
- 括号
  - 对于复杂规则，可以把公共部分提出来，然后用`(...)`把子规则括起来表示成`learn\\s(java|php|go)`

#### 4. 分组匹配

- 括号

  - `(...)`可以用来把一个子规则括起来
  - 实际上`(...)`还有一个重要作用，就是分组匹配，用来提取匹配的子串

- 使用

  - 必须引入`java.util.regex`包，用`Pattern`对象匹配，匹配后获得一个`Matcher`对象，如果匹配成功，就可以直接从`Matcher.group(index)`返回子串

  - ```java
    import java.util.regex.*;
    
    Pattern p = Pattern.compile("(\\d{3,4})\\-(\\d{7,8})");
    Matcher m = p.matcher("010-12345678");
    if (m.matches()) {
        String g1 = m.group(1); // 010
        String g2 = m.group(2); // 12345678
    }
    ```

  - 注意

    - `Matcher.group(index)`方法的参数用1表示第一个子串，2表示第二个子串
    - 传入0会得到整个正则匹配到的字符串

- 优势

  - `String.matches()`方法内部调用的就是`Pattern`和`Matcher`类的方法
  - 但是反复使用`String.matches()`对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的`Pattern`对象
  - 完全可以先创建出一个`Pattern`对象，然后反复使用，就可以实现编译一次，多次匹配

#### 5. 非贪婪匹配

- 贪婪匹配
  - 正则表达式默认使用贪婪匹配
  - 任何一个规则，它总是尽可能多地向后匹配
- 非贪婪匹配
  - 给定一个匹配规则，加上`?`后就变成了非贪婪匹配
- `?` 有两个作用
  - 修饰符`?`可以匹配0个或一个字符
  - 给定一个匹配规则，加上`?`后就变成了非贪婪匹配

#### 6. 操作字符串

- 分割

  - `String.split()`方法传入的正是正则表达式

- 搜索

  - 我们获取到`Matcher`对象后，不需要调用`matches()`方法（因为匹配整个串肯定返回false），而是反复调用`find()`方法，在整个串中搜索能匹配上`\\wo\\w`规则的子串，并打印出来

  - ```java
    String s = "the quick brown fox jumps over the lazy dog.";
    Pattern p = Pattern.compile("\\wo\\w");
    Matcher m = p.matcher(s);
    while (m.find())
        String sub = s.substring(m.start(), m.end());
    	// row, fox, dog
    ```

- 替换

  - 使用

    - 使用正则表达式替换字符串可以直接调用`String.replaceAll()`，它的第一个参数是正则表达式，第二个参数是待替换的字符串

    - ```java
      String s = "The     quick\t\t brown   fox  jumps   over the  lazy dog.";
      String r = s.replaceAll("\\s+", " "); 
      // The quick brown fox jumps over the lazy dog.
      ```

  - 反向引用
  
    - 使用`replaceAll()`的时候，我们传入的第二个参数可以使用`$1`、`$2`来反向引用匹配到的子串
  
    - ```java
      String s = "the quick brown fox jumps over the lazy dog.";
      String r = s.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
      // the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.
      ```



## 第十八章 函数式编程

- Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带`this`参数的函数
- 函数式编程最早是数学家[阿隆佐·邱奇](https://zh.wikipedia.org/wiki/阿隆佐·邱奇)研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算
- Java平台从Java 8开始，支持函数式编程

### 1. Lambda 基础

- 函数
  - 无论是实例方法，还是静态方法，本质上都相当于过程式语言的函数
  - 只不过Java的实例方法隐含地传入了一个`this`变量
  - 函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数

- Lambda 表达式
  - 单方法接口
    
    - 在Java程序中，我们经常遇到一大堆单方法接口，即一个接口只定义了一个方法，例如 Comparator，Runnable，Callable
    
    - 我们把只定义了单方法的接口称之为`FunctionalInterface`，用注解`@FunctionalInterface`标记
    
    - ```java
      Arrays.sort(array, new Comparator<String>() {
          public int compare(String s1, String s2) {
              return s1.compareTo(s2);
          }
      });
      ```
    
  - 从Java 8开始，我们可以用Lambda表达式替换单方法接口
  
    - ```java
      Arrays.sort(array, (s1, s2) -> {
          return s1.compareTo(s2);
      });
      ```
  
    - 只需要写出方法定义
  
    - 参数类型可以省略，因为编译器可以自动推断出`String`类型
  
    - `-> { ... }`表示方法体，如果只有一行 `return xxx `的代码则可以直接写成 `-> xxx `
  
    - 返回值的类型也是由编译器自动推断的

### 2. 方法引用

- 简介

  - 为了替换替换单方法接口，除了 Lambda 表达式，我们还可以直接传入方法引用
  - 所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用
  - 注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系

- 静态方法引用

  - ```java
    public class Main {
        public static void main(String[] args) {
            String[] array = new String[] {"Apple", "Orange", "Banana"};
            Arrays.sort(array, Main::cmp);
        }
    
        static int cmp(String s1, String s2) {
            return s1.compareTo(s2);
        }
    }
    ```

- 实例方法引用

  - ```java
    Arrays.sort(array, String::compareTo);
    ```

  - 注意，`String::compareTo` 的签名只有一个参数，这里之所以能匹配，是因为实例方法有一个隐含的`this`参数

  - ```java
    public final class String {
    	public int compareTo(String o) {...}
    }
    ```

- 构造方法引用

  - ```java
    List<String> names = List.of("Bob", "Alice", "Tim");
    List<Person> persons = names.stream().map(Person::new).collect(Collectors.toList());
    ```

  - 如果要把一个`List<String>`转换为`List<Person>`，传统的做法是先定义一个`ArrayList<Person>`，然后用`for`循环填充这个`List`

  - 要更简单地实现`String`到`Person`的转换，我们可以引用`Person`的构造方法，构造方法的引用写法是`类名::new`

  - 这里的`map()`需要传入的FunctionalInterface的定义是

    - ```java
      @FunctionalInterface
      public interface Function<T, R> {
          R apply(T t);
      }
      ```

    - 把泛型对应上就是方法签名`Person apply(String)`

### 3. Stream

- 简介
  - Java从8开始，不但引入了Lambda表达式，还引入了一个全新的流式API：Stream API。它位于`java.util.stream`包中
- 特点
  - 代表任意Java对象的序列
  - 输出的元素可能并没有预先存储在内存中，而是实时计算出来的
  - 一个`Stream`可以轻易地转换为另一个`Stream`，而不是修改原`Stream`本身
  - 一个`Stream`转换为另一个`Stream`时，实际上只存储了转换规则，并没有任何计算发生，真正的计算通常发生在最后结果的获取，也就是惰性计算
- 总结
  - Stream API提供了一套新的流式处理的抽象序列
  - Stream API支持函数式编程和链式操作
  - Stream可以表示无限序列，并且大多数情况下是惰性求值的

#### 1. 创建

- Stream.of()

  - 创建`Stream`最简单的方式是直接用`Stream.of()`静态方法，传入可变参数即创建了一个能输出确定元素的`Stream`

  - ```java
    Stream<String> stream = Stream.of("A", "B", "C", "D");
    ```

  - 虽然这种方式基本上没啥实质性用途，但测试的时候很方便

- 基于数组或Collection

  - 这样该`Stream`输出的元素就是数组或者`Collection`持有的元素

  - ```java
    // 数组
    Stream<String> stream1 = Arrays.stream(new String[] { "A", "B", "C" });
    // Collection（List、Set、Queue等）
    Stream<String> stream2 = List.of("X", "Y", "Z").stream();
    ```

  - 把一个现有的序列变为`Stream`，它的元素是固定的

- 基于Supplier

  - 创建`Stream`还可以通过`Stream.generate()`方法，它需要传入一个`Supplier`对象

  - ```java
    Stream<Integer> s = Stream.generate(new NatualSupplier());
    
    class NatualSupplier implements Supplier<Integer> {
        int n = 0;
        public Integer get() {
            n++;
            return n;
        }
    }
    ```

  - 特点

    - 基于`Supplier`创建的`Stream`会不断调用`Supplier.get()`方法来不断产生下一个元素
    - 这种`Stream`保存的不是元素，而是算法，它可以用来表示无限序列

  - 注意

    - 对于无限序列，如果直接调用`forEach()`或者`count()`这些最终求值操作，会进入死循环
    - 所以正确的方法是先把无限序列变成有限序列，例如，用`limit()`方法可以截取前面若干个元素

- 其他方法

  - 通过一些API提供的接口，直接获得`Stream`

  - lines()

    - `Files`类的`lines()`方法可以把一个文件变成一个`Stream`，每个元素代表文件的一行内容

    - ```java
      Stream<String> lines = Files.lines(Paths.get("/path/to/file.txt"))
      ```

  - splitAsStream()

    - 正则表达式的`Pattern`对象有一个`splitAsStream()`方法，可以直接把一个长字符串分割成`Stream`序列而不是数组

    - ```java
      Pattern p = Pattern.compile("\\s+");
      Stream<String> s = p.splitAsStream("The quick brown fox jumps over the lazy dog");
      ```

- 基本类型
  - 问题
    - 因为Java的范型不支持基本类型，所以我们无法用`Stream<int>`这样的类型
    - 为了保存`int`，只能使用`Stream<Integer>`，但这样会产生频繁的装箱、拆箱操作，影响效率
  - 解决
    - 为了提高效率，Java标准库提供了`IntStream`、`LongStream`和`DoubleStream`这三种使用基本类型的`Stream`

#### 2. 使用 map

- 简介

  - 把一种操作运算，映射到一个序列的每一个元素上

  - ```java
    Stream<Integer> s = Stream.of(1, 2, 3, 4, 5).map(n -> n * n);
    ```

- 分析

  - `map()`方法接收的对象是`Function`接口对象

    - ```java
      <R> Stream<R> map(Function<? super T, ? extends R> mapper);
      ```

  - `Function`接口对象定义了一个`apply()`方法，负责把一个`T`类型转换成`R`类型

    - ```java
      @FunctionalInterface
      public interface Function<T, R> {
          // 将T类型转换为R:
          R apply(T t);
      }
      ```

#### 3. 使用 filter

- 简介

  - 对一个`Stream`的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的`Stream`

  - ```java
    IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
        .filter(n -> n % 2 != 0)
        .forEach(System.out::println); // 1, 3, 5, 7, 9
    ```

- 分析

  - `filter()`方法接收的对象是`Predicate`接口对象，它定义了一个`test()`方法，负责判断元素是否符合条件

    - ```java
      @FunctionalInterface
      public interface Predicate<T> {
          // 判断元素t是否符合条件:
          boolean test(T t);
      }
      ```

#### 4. 使用 reduce

- 简介

  - `map()`和`filter()`都是`Stream`的转换方法，而`Stream.reduce()`则是`Stream`的一个聚合方法，它可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果
  - 聚合方法会立刻对`Stream`进行计算

- 分析

  - `reduce()`方法传入的对象是`BinaryOperator`接口，它定义了一个`apply()`方法，负责把上次累加的结果和本次的元素进行运算，并返回累加的结果

  - ```java
    @FunctionalInterface
    public interface BinaryOperator<T> {
        // Bi操作：两个输入，一个输出
        T apply(T t, T u);
    }
    ```

- 举例

  - 求和

    - ```java
      int sum = Stream.of(1, 2, 3).reduce(0, (acc, n) -> acc + n); // 6
      ```

  - 求积

    - ```java
      int s = Stream.of(1, 2, 3).reduce(1, (acc, n) -> acc * n); // 6
      ```

- 去掉初始值

  - 如果去掉初始值，我们会得到一个`Optional<Integer>`

  - ```java
    Optional<Integer> opt = stream.reduce((acc, n) -> acc + n);
    if (opt.isPresent) {
        System.out.println(opt.get());
    }
    ```

  - 这是因为`Stream`的元素有可能是0个，这样就没法调用`reduce()`的聚合函数了，因此返回`Optional`对象，需要进一步判断结果是否存在

#### 5. 输出集合

- 操作分类

  - 转换操作
    - 把一个`Stream`转换为另一个`Stream`
    - 对 Stream 进行转换操作并不会触发任何计算
  - 聚合操作
    - 对`Stream`的每个元素进行计算，得到一个确定的其他的Java对象
    - 对一个`Stream`进行聚合操作，会触发真正的计算

- 输出为List

  - 因为`List`的元素是确定的Java对象，因此，把`Stream`变为`List`不是一个转换操作，而是一个聚合操作，它会强制`Stream`输出每个元素

  - ```java
    List<String> list = stream.collect(Collectors.toList());
    // 类似的，collect(Collectors.toSet()) 将 Stream 转化为 set
    ```

  - 调用`collect()`并传入`Collectors.toList()`对象，它实际上是一个`Collector`实例，通过类似`reduce()`的操作，把每个元素添加到一个收集器中（实际上是`ArrayList`）

- 输出为数组

  - ```java
    String[] array = stream.toArray(String[]::new);
    ```

  - 注意到传入的“构造方法”是`String[]::new`，它的签名实际上是`IntFunction<String[]>`定义的`String[] apply(int)`，即传入`int`参数，获得`String[]`数组的返回值

- 输出为Map

  - 对于每个元素，添加到Map时需要key和value，因此，我们要指定两个映射函数，分别把元素映射为key和value

  - ```java
    Stream<String> stream = Stream.of("APPL:Apple", "MSFT:Microsoft");
    Map<String, String> map = stream
        .collect(
        	Collectors.toMap(
                // 把元素s映射为key:
                s -> s.substring(0, s.indexOf(':')),
                // 把元素s映射为value:
                s -> s.substring(s.indexOf(':') + 1)
        	)
        );
    ```

- 分组输出

  - ```java
    List<String> list = List.of("Apple", "Banana", "Blackberry", "Coconut", "Avocado", "Cherry", "Apricots");
    Map<String, List<String>> groups = list.stream()
        .collect(
        	Collectors.groupingBy(
                s -> s.substring(0, 1), Collectors.toList()
            )
    	);
    ```

  - 分组输出使用`Collectors.groupingBy()`，它需要提供两个函数

    - 一个是分组的key，这里使用`s -> s.substring(0, 1)`，表示只要首字母相同的`String`分到一组
    - 第二个是分组的value，这里直接使用`Collectors.toList()`，表示输出为`List`

#### 6. 其他操作