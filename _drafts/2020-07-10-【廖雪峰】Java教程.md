---
layout: post
title:  【廖雪峰】Java教程 I
date:   2020-07-10
categories: Java
---

- 优势
  - Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行
  - Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理
  - Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验
  - Java拥有最广泛的开源社区支持，各种高质量组件随时可用
- 应用场景
  - 互联网和企业应用，这是Java EE的长期优势和市场地位
  - 大数据平台，主要有Hadoop、Spark、Flink等，他们都是Java或Scala（一种运行于JVM的编程语言）开发的
  - Android移动平台

## 第一章 快速入门

### 1. 简介

- 历史
  - Java最早是由SUN公司（已被Oracle收购）的[詹姆斯·高斯林](https://en.wikipedia.org/wiki/James_Gosling)（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak
  - SUN公司改造了Oak，在1995年以Java的名称正式发布
- 特点
  - Java介于编译型语言和解释型语言之间
  - Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果
- 分类
  - Java SE：Standard Edition
  - Java EE：Enterprise Edition
  - Java ME：Micro Edition
  - 简单来说，Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等
- 名词解释
  - JDK：Java Development Kit
  - JRE：Java Runtime Environment
  - 简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具
  - JSR规范：Java Specification Request
  - JCP组织：Java Community Process

#### 1. 安装 JDK

- 下载
- 设置环境变量
- `JAVA_HOME`的`bin`目录
  - java
    - 这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码
  - javac
    - 这是Java的编译器，它用于把Java源码文件（以`.java`后缀结尾）编译为Java字节码文件（以`.class`后缀结尾）
  - jar
  - javadoc
  - jdb

#### 2. 第一个 Java 程序

- 编写

  - 可以使用任意编辑器
  - 文件名必须是`Hello.java`，而且文件名也要注意大小写，因为要和我们定义的类名`Hello`完全保持一致

- 编译

  - ```shell
    $ javac Hello.java
    ```

  - `Hello.java => Hello.class` 

- 运行

  - ```shell
    $ java Hello
    ```

  - 给虚拟机传递的参数`Hello`是我们定义的类名，虚拟机自动查找对应的class文件并执行

  - 直接运行`java Hello.java`也是可以的，这是 Java 11 新增的一个功能，它可以直接运行一个单文件源码

#### 3. 代码助手

- Java代码运行助手可以让你在线输入Java代码，然后远程运行后，在网页显示代码执行结果

#### 4. IDE

- IDE是集成开发环境：Integrated Development Environment的缩写

- 使用IDE的好处在于，可以把编写代码、组织项目、编译、运行、调试等放到一个环境中运行，能极大地提高开发效率

- 目前，流行的用于Java开发的IDE有

  - ### Eclipse

  - ### IntelliJ Idea

  - ### NetBeans

#### 5. IDE练习插件

- 教程的提供一个Eclipse IDE的练习插件，可以非常方便地下载练习代码



### 2. 基础

#### 1. 程序基本结构

- 因为Java是面向对象的语言，一个程序的基本单位就是`class`
- 类名要求
  - 类名必须以英文字母开头，后接字母，数字和下划线的组合
  - 习惯以大写字母开头
- 方法名也有命名规则，命名和`class`一样，但是首字母小写

#### 2. 数据类型

- 在Java中，变量分为两种：基本类型的变量和引用类型的变量

- 变量类型

  - 基本数据类型

    - 基本数据类型是CPU可以直接进行运算的类型，Java定义了以下几种基本数据类型

    - 整型

      - 对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）

      - byte [1]，short [2]，int [4]，long [8]

      - ```java
        int i3 = 2_000_000_000; // 加下划线更容易识别
        int i4 = 0xff0000; // 十六进制表示的16711680
        int i5 = 0b1000000000; // 二进制表示的512
        long l = 9000000000000000000L; // long型的结尾需要加L
        ```

    - 浮点型

      - float [4]，double [8]

      - ```java
        float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38，对于float类型，需要加上f后缀
        ```

    - 布尔类型

      - boolean [4]

    - 字符类型

      - char [2]
      - Java的`char`类型除了可表示标准的ASCII外，还可以表示一个Unicode字符

  - 引用类型

    - 除了上述基本类型的变量，剩下的都是引用类型
    - 引用类型的变量类似于C语言的指针，它内部存储一个“地址”

- 常量

  - ```java
    final double PI = 3.14; // PI是一个常量
    ```

- 补充

  - var关键字
    - 有些时候，类型的名字太长，写起来比较麻烦，如果想省略变量类型，可以使用`var`关键字
  - 作用范围
    - 在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束
    - 要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域

#### 3. 整数

- 四则运算
  - 两个整数相除只能得到结果的整数部分
- 溢出
  - 整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出*不会出错*，却会得到一个奇怪的结果
- 自增/自减
  - 注意`++`写在前面和后面计算结果是不同的，`++n`表示先加1再引用n，`n++`表示先引用n再加1。不建议把`++`运算混入到常规运算中
- 移位运算
  - 左移 `<<` 实际上就是不断地×2，右移 `>>` 实际上就是不断地÷2
  - 对`byte`和`short`类型进行移位时，会首先转换为`int`再进行位移
  - 还有一种无符号的右移运算，使用`>>>`，它的特点是不管符号位，右移后高位总是补`0`

- 位运算
  - 位运算是按位进行与、或、非、异或的运算
- 运算优先级
- 类型自动提升与强制转型
  - 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型
  - 也可以将结果强制转型，即将大范围的整数转型为小范围的整数，但超出范围的强制转型会得到错误的结果

#### 4. 浮点数

- 运算

  - 浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算

- 误差

  - 在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示
  - 由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数

- 类型提升

  - 如果参与运算的两个数其中一个是浮点型，那么整型可以自动提升到浮点型

- 溢出

  - 整数运算在除数为`0`时会报错，而浮点数运算在除数为`0`时，不会报错，但会返回几个特殊值

  - ```java
    double d1 = 0.0 / 0; // NaN
    double d2 = 1.0 / 0; // Infinity
    double d3 = -1.0 / 0; // -Infinity
    ```

- 强制转型

  - 可以将浮点数强制转型为整数
  - 在转型时，浮点数的小数部分会被丢掉
  - 如果转型后超过了整型能表示的最大范围，将返回整型的最大值
  - 如果要进行四舍五入，可以对浮点数加上0.5再强制转型

#### 5. 布尔类型

- 对于布尔类型`boolean`，永远只有`true`和`false`两个值
- 关系运算符的优先级从高到低依次是：
  - `!`
  - `>`，`>=`，`<`，`<=`
  - `==`，`!=`
  - `&&`
  - `||`
- 短路运算
  - 布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果
- 三元运算符
  - Java还提供一个三元运算符`b ? x : y`，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果
  - `x`和`y`的类型必须相同，因为返回值不是`boolean`，而是`x`和`y`之一

#### 6. 字符和字符串

- 在Java中，字符和字符串是两个不同的类型

- 字符类型

  - 字符类型`char`是基本数据类型，它是`character`的缩写

  - 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个`char`类型表示，它们都占用两个字节

  - char 和 int 之间可以互相转换，核心的 unicode 编码不变

  - ```java
    int n1 = 'A'; // 字母“A”的Unicodde编码是65
    int n2 = '中'; // 汉字“中”的Unicode编码是20013
    // 注意是十六进制:
    char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
    char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
    ```

- 字符串类型

  - 特点

    - 字符串类型`String`是引用类型，我们用双引号`"..."`表示字符串
    - 如果字符串本身恰好包含一个`"`字符，就需要借助转义字符`\`

  - 转义字符
    - `\"` 表示字符`"`
    - `\'` 表示字符`'`
    - `\\` 表示字符`\`
    - `\n` 表示换行符
    - `\r` 表示回车符
    - `\t` 表示Tab
    - `\u####` 表示一个Unicode编码的字符

  - 字符串连接

    - Java的编译器对字符串做了特殊照顾，可以使用`+`连接任意字符串和其他数据类型
    - 如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接

  - 多行字符串

    - 从Java 13开始，字符串可以用`"""..."""`表示多行字符串（Text Blocks）了
  
    - 注意：多行字符串前面共同的空格会被去掉，如果多行字符串的排版不规则，那么，去掉的空格总是以最短的行首空格为基准

    - 补充：由于多行字符串是作为预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数

    - ```shell
    $ javac --source 14 --enable-preview Main.java
      ```

  - 不可变特性
  
    - Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变
  
  - 空值null
  
    - ```java
      String s1 = null; // s1是null
      String s2; // 没有赋初值值，s2也是null
      String s3 = s1; // s3也是null
      String s4 = ""; // s4指向空字符串，不是null
      ```

#### 7. 数组

- 定义和初始化

  - 定义一个数组类型的变量，使用数组类型“类型[]”，例如，`int[]`

  - 和单个基本类型变量不同，数组变量初始化必须使用`new int[5]`表示创建一个可容纳5个`int`元素的数组

  - 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小

  - ```java
    int[] ns = new int[5];
    int[] ns = new int[] { 68, 79, 91, 85, 62 };
    int[] ns = { 68, 79, 91, 85, 62 };						// 简写
    ```

  - 

- 注意

  - 数组所有元素初始化为默认值，整型都是`0`，浮点型是`0.0`，布尔型是`false`
  - 数组一旦创建后，大小就不可改变

- 操作

  - 可以修改数组中的某一个元素，使用赋值语句，例如，`ns[1] = 79;`
  - 可以用`数组变量.length`获取数组大小

- 字符串数组

  - 数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型



### 3. 流程控制

#### 1. 输入/输出

- 输出
  - 输出函数
    - `System.out.println()`
    - `System.out.print()`
  - 格式化输出
    - `System.out.printf()`
    - 通过使用占位符`%?`，`printf()`可以把后面的参数格式化成指定格式
    - 注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身
- 输入
  - 首先，我们通过`import`语句导入`java.util.Scanner`
  - 然后，创建`Scanner`对象并传入`System.in`
  - 有了`Scanner`对象后，要读取用户输入的字符串，使用`scanner.nextLine()`，要读取用户输入的整数，使用`scanner.nextInt()`

#### 2. `if` 判断

- 用法

  - ```java
    if (条件) {
        // 条件满足时执行
    } else if () {
    } else {}
    ```

  - 当`if`语句块只有一行语句时，可以省略花括号{}

- 注意

  - 浮点数

    - 前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用`==`判断不靠谱，正确的方法是利用差值小于某个临界值来判断

  - 引用类型

    - 判断引用类型的变量是否相等，`==`表示“引用是否相等”，或者说，是否指向同一个对象

    - 要判断引用类型的变量内容是否相等，必须使用`equals()`方法

    - 执行语句`s1.equals(s2)`时，如果变量`s1`为`null`，会报`NullPointerException`

    - ```java
      // 要避免NullPointerException错误，可以利用短路运算符&&
      if (s1 != null && s1.equals("hello")) {}
      // 还可以把一定不是null的对象"hello"放到前面
      if ("hello".equals(s)) {}
      ```

#### 3. `switch` 多重选择

- 用法

  - 除了if语句外，还有一种条件判断，是根据某个表达式的结果，分别去执行不同的分支

  - ```java
    switch (option) {
      case 1:
        System.out.println("Selected 1");
        break;
      case 2:
        System.out.println("Selected 2");
        break;
      default:
        System.out.println("Not selected");
        break;
    }
    ```

- 注意

  - `case`语句并没有花括号`{}`
  - `case`语句具有“穿透性”（fall-through），漏写 `break` 将导致程序连续执行多个 `case`
  - 只要保证有`break`，`case`的顺序不影响程序逻辑
  - `switch`语句还可以匹配字符串。字符串匹配时，是比较“内容相等”
  - `switch`语句还可以使用枚举类型

- 新语法

  - 从Java 12开始，`switch`语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法

  - 保证只有一种路径会被执行，并且不需要`break`语句

  - ```java
    switch (fruit) {
        case "apple" -> System.out.println("Selected apple");
        case "pear" -> System.out.println("Selected pear");
        case "mango" -> {
            System.out.println("Selected mango");
            System.out.println("Good choice!");
        }
        default -> System.out.println("No fruit selected");
    }
    ```

  - 使用新的`switch`语法，不但不需要`break`，还可以直接返回值

  - ```java
    int opt = switch (fruit) {
        case "apple" -> 1;
        case "pear", "mango" -> 2;
        default -> {
            int code = fruit.hashCode();
            yield code; // switch语句返回值
        }
    }; // 注意赋值语句要以;结束
    ```


#### 4. `while` 循环

- `while`循环先判断循环条件是否满足，再执行循环语句
- `while`循环可能一次都不执行
- 编写循环时要注意循环条件，并避免死循环
  - 表面上看，有些的`while`循环是一个死循环，但是，Java的`int`类型有最大值，达到最大值后，再加1会变成负数，结果，意外退出了`while`循环

#### 5. `do while` 循环

- `do while`循环先执行循环，再判断条件，会至少循环一次

#### 6. `for` 循环

- 使用

  - `for`循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为`i`

- 注意

  - `for`循环的初始化计数器总是会被执行，并且`for`循环也可能循环0次
  - 尽量不要在循环体内修改计数器
  - 使用`for`循环时，计数器变量`i`要尽量定义在`for`循环中
  - `for`循环还可以缺少初始化语句、循环条件和每次循环更新语句

- `for each` 循环

  - ```java
    for (int n : ns) {
        System.out.println(n);
    }
    ```

  - `for each`循环的变量n不再是计数器，而是直接对应到数组的每个元素

  - `for each`循环的写法更简洁，但是，`for each`循环无法指定遍历顺序，也无法获取数组的索引

  - 除了数组外，`for each`循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的`List`、`Map`等

#### 7. `break` 和 `continue`

- `Break`，`continue` 语句通常都是配合`if`语句使用
- break
  - `break`会跳出当前循环，也就是整个循环都不会执行了
  - 要特别注意，`break`语句总是跳出自己所在的那一层循环
- continue
  - 而`continue`则是提前结束本次循环，直接继续执行下次循环
  - 在多层嵌套的循环中，`continue`语句同样是结束本次自己所在的循环



### 4. 数组操作

#### 1. 遍历

- 遍历

  - for 循环
  - for each 循环

- 输出

  - ```java
    int[] ns = { 1, 1, 2, 3, 5, 8 };
    // 1. 直接打印数组变量，得到的是数组在JVM中的引用地址
    System.out.println(ns); // 类似 [I@7852e922
    // 2. 手动打印的数组的元素内容
    for (int n : ns) {
        System.out.print(n + ", ");
    }
    // 3. Java标准库提供了Arrays.toString()，可以快速打印数组内容
    System.out.println(Arrays.toString(ns)); // [1, 1, 2, 3, 5, 8]
    ```

#### 2. 排序

- 手动排序

- 内置排序函数

  - ```java
    Arrays.sort(ns);
    ```

  - 注意

    - 对数组排序实际上修改了数组本身

#### 3. 多维数组

- 定义

  - ```java
    // 二维数组的每个数组元素的长度并不要求相同
    int[][] ns = {
        { 1, 2, 3, 4 },
        { 5, 6 },
        { 7, 8, 9 }
    };
    ```

- 使用
  
  - 访问二维数组的某个元素需要使用`array[row][col]`
- 输出
  - 手动打印
    - 两层嵌套的for循环
  - 自动打印
    - `Arrays.deepToString()`

#### 4. 命令行参数

- 命令行参数类型是`String[]`数组
- 命令行参数由JVM接收用户输入并传给`main`方法
- 如何解析命令行参数需要由程序自己实现



## 第二章 面向对象

### 1. 基础

- class
  - 一个`class`可以包含多个字段（`field`）
- instance
  - new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例
  - 访问实例变量可以用`变量.字段`

#### 1. 方法 `method`

- 定义

  - ```java
    修饰符 方法返回类型 方法名(方法参数列表) {
        若干方法语句;
        return 方法返回值; 
    }
    ```

  - 如果没有返回值，返回类型设置为void，可以省略return，注意和返回null不同

- this 变量

  - 在方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例
  - 如果没有命名冲突，可以省略`this`
  - 如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上`this`

- 参数

  - 普通参数
    - 调用方法时，必须严格按照参数的定义一一传递
  - 可变参数
    - 可变参数用`类型...`定义，可变参数相当于数组类型
    - 优势
      - 调用方不需要自己先构造`String[]`，写起来方便
      - 可变参数可以保证无法传入`null`，因为传入0个参数时，接收到的实际值是一个空数组而不是`null`

- 参数绑定

  - 基本类型
    - 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响
  - 引用类型
    - 引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方

#### 2. 构造方法

- 特点
  - 构造方法的名称就是类名
  - 构造方法没有返回值（也没有`void`）
  - 调用构造方法，必须用`new`操作符
- 默认构造方法
  - 如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句
  - 如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法
- 字段的默认值
  - 没有在构造方法中初始化字段时，引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型默认值是`false`
  - 既对字段进行初始化，又在构造方法中对字段进行初始化，最终以构造方法为准
  - 这是因为创建对象实例的时候，按照如下顺序进行初始化
    1. 先初始化字段
    2. 执行构造方法的代码进行初始化
- 多构造方法
  - 可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分
  - 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用，调用其他构造方法的语法是`this(…)`

#### 3. 重载

- 简介
  - 如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法
  - 这种方法名相同，但各自的参数不同，称为方法重载（`Overload`）
  - 功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单
- 注意
  - 方法重载的返回值类型通常都是相同的

#### 4. 继承

- 使用

  - Java使用`extends`关键字来实现继承
  - 在OOP的术语中，我们把`Person`称为超类（super class），父类（parent class），基类（base class），把`Student`称为子类（subclass），扩展类（extended class）

- 注意

  - 类自动获得了父类的所有字段，严禁定义与父类重名的字段
  - 在Java中，没有明确写`extends`的类，编译器会自动加上`extends Object`
  - Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类
  - 只有`Object`特殊，它没有父类

- 访问权限

  - 继承有个特点，就是子类无法访问父类的`private`字段或者`private`方法
  - `protected`关键字可以把字段和方法的访问权限控制在继承树内部，一个`protected`字段和方法可以被其子类，以及子类的子类所访问

- super 关键字

  - `super`关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`
  - 实际上，这里使用`super.name`，或者`this.name`，或者`name`，效果都是一样的。编译器会自动定位到父类的`name`字段
  - 但是，在某些时候，在构造方法中，或者想要显式调用父类方法时，就必须使用`super`

- 构造方法

  - 在Java中，任何`class`的构造方法，第一行语句必须是调用父类的构造方法
  - 如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句`super();`
  - 但是，如果父类并没有无参数的构造方法，就会编译失败
  - 解决方法是使用 `super()` 显示调用父类存在的某个构造方法
  - 这也说明子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的

- 转型

  - 向上转型
    - 把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）
  - 向下转型
    - 和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）
    - 如果一个变量指向的实例确实是子类，则成功，但如果指向的实例确实是父类，则会失败

- `instanceof`

  - `instanceof`实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类

  - 从Java 14开始，判断`instanceof`后，可以直接转型为指定变量，避免再次强制转型

  - ```java
    if (obj instanceof String s) {
        // 可以直接使用变量s:
        System.out.println(s.toUpperCase());
    }
    ```

  - 补充：使用`instanceof variable`这种判断并转型为指定类型变量的语法时，必须打开编译器开关`--source 14`和`--enable-preview`

- 继承和组合
  - `Student`是`Person`的一种，它们是is关系，而`Student`和`Book`的关系是has关系
  - 具有has关系不应该使用继承，而是使用组合，即`Student`可以持有一个`Book`实例
  - 因此，继承是is关系，组合是has关系

#### 5. 多态

- 覆写

  - 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）

  - Override和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是`Override`

  - 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错

    |      | 方法名称 | 参数列表 | 返回值           | 访问修饰符 |
    | ---- | -------- | -------- | ---------------- | ---------- |
    | 重载 | 相同     | 不同     | 无所谓，通常相同 | 无所谓     |
    | 覆写 | 相同     | 相同     | 相同             | 无所谓     |
    | 错误 | 相同     | 相同     | 不同             | 无所谓     |

- `@Override`

  - 加上`@Override`可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错
  - 但是`@Override`不是必需的

- 多态

  - 定义
    - Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型
    - 这个非常重要的特性在面向对象编程中称之为多态（Polymorphic）
    - 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法
  - 优势
    - 多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码

- 覆写Object方法

  - 因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法
    - `toString()`：把instance输出为`String`
    - `equals()`：判断两个instance是否逻辑相等
    - `hashCode()`：计算一个instance的哈希值
  - 在必要的情况下，我们可以覆写`Object`的这几个方法

- 调用super

  - 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用

- `final`

  - 如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`，用`final`修饰的方法不能被`Override`
  - 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为`final`，用`final`修饰的类不能被继承
  - 对于一个类的实例字段，同样可以用`final`修饰，用`final`修饰的字段在初始化后不能被修改，可以在构造方法中初始化final字段

#### 6. 抽象类 `abstract`

- 定义
  - 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法
  - 把一个方法声明为`abstract`，表示它是一个抽象方法，本身没有实现任何方法语句
  - 同时必须把父类本身也声明为`abstract`，才能正确编译它，但是抽象类无法被实例化
- 优势
  - 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错
  - 因此，抽象方法实际上相当于定义了“规范”
  - 另一方面，我们可以通过抽象类`Person`类型去引用具体的子类的实例（面向抽象编程）
- 面向抽象编程
  - 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程
  - 特点
    - 上层代码只定义规范（例如：`abstract class Person`）
    - 不需要子类就可以实现业务逻辑（正常编译）
    - 具体的业务逻辑由不同的子类实现，调用者并不关心

#### 7. 接口 `interface`

- 动机
  - 在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现
  - 如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口（interface）
- 使用
  - 在Java中，使用`interface`可以声明一个接口
  - 当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字
- 特点
  - 所谓`interface`，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有
  - 因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）
  - 在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`
- 补充
  - Java的接口特指`interface`的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等
- 接口继承
  - 一个`interface`可以继承自另一个`interface`
  - `interface`继承自`interface`使用`extends`
- `default`
  - 在接口中，可以定义`default`方法，实现类可以不必覆写`default`方法
  - `default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法
  - `default`方法和抽象类的普通方法是有所不同的。因为`interface`没有字段，`default`方法无法访问字段，而抽象类的普通方法可以访问实例字段

|            | abstract class | interface                   |
| ---------- | -------------- | --------------------------- |
| 继承       | extends 一个   | implements 多个             |
| 实例字段   | 可以           | 不能定义实例字段            |
| 静态字段   | 可以           | 可以，`public static final` |
| 抽象方法   | 可以           | 可以                        |
| 非抽象方法 | 可以           | 可以定义 default 方法       |

#### 8. 静态 `static`

- 静态字段
  - 实例字段
    - 在一个`class`中定义的字段，我们称之为实例字段，实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响
  - 还有一种字段，是用`static`修饰的字段，称为静态字段，静态字段只有一个共享“空间”，所有实例都会共享该字段
  - 特点
    - 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了
    - 因此，不推荐用`实例变量.静态字段`去访问静态字段，推荐用类名来访问静态字段
- 静态方法
  - 用`static`修饰的方法称为静态方法
  - 因为静态方法属于`class`而不属于实例，因此，静态方法内部，无法访问`this`变量，也无法访问实例字段，它只能访问静态字段
  - 用法
    - 静态方法经常用于工具类，例如 `Arrays.sort(), Math.random()`
    - 静态方法也经常用于辅助方法。注意到Java程序的入口`main()`也是静态方法
- 接口的静态字段
  - 因为`interface`是一个纯抽象类，所以它不能定义实例字段
  - 但是，`interface`是可以有静态字段的，并且静态字段必须为`final`类型
  - 实际上，因为`interface`的字段只能是`public static final`类型，所以我们可以把这些修饰符都去掉

#### 9. 包 `package`

- 简介

  - 在Java中，我们使用`package`来解决名字冲突
  - Java定义了一种名字空间，称之为包：`package`

- 特点

  - 一个类总是属于某个包，类名（比如`Person`）只是一个简写，真正的完整类名是`包名.类名`
  - 包可以是多层结构，用`.`隔开。例如：`java.util`
  - 注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系
  - 没有定义包名的`class`，它使用的是默认包，非常容易引起名字冲突

- 使用

  - 在定义`class`的时候，我们需要在第一行声明这个`class`属于哪个包

  - ```java
    package ming;
    ```

  - 所有Java文件对应的目录层次要和包的层次一致

  - ```shell
    $ javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java
    ```

- 包作用域

  - 不用`public`、`protected`、`private`修饰的字段和方法就是包作用域
  - 位于同一个包的类，可以访问包作用域的字段和方法

- `import`

  - 在一个`class`中，我们总会引用其他的`class`，有三种写法
    - 直接写出完整类名
    - 用`import`语句，导入小军的`Arrays`，然后写简单类名
    - `import static`的语法，可以导入一个类的静态字段和静态方法，很少使用
  - 如果有两个`class`名称相同，例如，`mr.jun.Arrays`和`java.util.Arrays`，那么只能`import`其中一个，另一个必须写完整类名

- 编译过程

  - Java编译器最终编译出的`.class`文件只使用*完整类名*，因此，在代码中，当编译器遇到一个`class`名称时
    - 如果是完整类名，就直接根据完整类名查找这个`class`
    - 如果是简单类名，按下面的顺序依次查找
      - 查找当前`package`是否存在这个`class`
      - 查找`import`的包是否包含这个`class`
      - 查找`java.lang`包是否包含这个`class`
  - 如果按照上面的规则还无法确定类名，则编译报错
  - 因此，编写class的时候，编译器会自动帮我们做两个import动作
    - 默认自动`import`当前`package`的其他`class`
    - 默认自动`import java.lang.*`
  - 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入

- 编程规范

  - 为了避免名字冲突，我们需要确定唯一的包名，推荐的做法是使用倒置的域名来确保唯一性
  - 子包就可以根据功能自行命名
  - 要注意不要和`java.lang`包的类重名，也不要和JDK常用类重名

#### 10. 作用域

- 定义
  - 我们经常看到`public`、`protected`、`private`这些修饰符。在Java中，这些修饰符可以用来限定访问作用域
- `public`
  - `class`、`interface`
    - 可以被其他任何类访问
  - `field`、`method`
    - 可以被其他类访问，前提是首先有访问`class`的权限
- `private`
  - `field`、`method`
    - 无法被其他类访问
    - 确切地说，`private`访问权限被限定在`class`的内部
  - 补充
    - 与方法声明顺序无关，推荐把`private`方法放到后面，因为`public`方法定义了类对外提供的功能，阅读代码的时候，应该先关注`public`方法
    - 由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问`private`的权限
- `protected`
  - `field`、`method`
    - `protected`作用于继承关系。定义为`protected`的字段和方法可以被子类访问，以及子类的子类
- package
  - `class`、`interface`
    - 包作用域是指一个类允许访问同一个`package`的没有`public`、`private`修饰的`class`
  - `field`、`method`
    - 以及没有`public`、`protected`、`private`修饰的字段和方法
- 局部变量
  - 在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束
  - 方法参数也是局部变量
  - 使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量
- `final`
  - Java还提供了一个`final`修饰符，`final`与访问权限不冲突
  - `class`
    - 阻止被继承
  - `method`
    - 阻止被子类覆写
  - `field`
    - 阻止被重新赋值
  - 局部变量
    - 阻止被重新赋值
- 规范写法
  - 如果不确定是否需要`public`，就不声明为`public`，即尽可能少地暴露对外的字段和方法
  - 把方法定义为`package`权限有助于测试，因为测试类和被测试类只要位于同一个`package`，测试代码就可以访问被测试类的`package`权限方法
  - 一个`.java`文件只能包含最多一个`public`类，但可以包含多个非`public`类
  - 如果有`public`类，文件名必须和`public`类的名字相同

#### 11. classpath 和 jar

- classpath
  - 简介
    - `classpath`是JVM用到的一个环境变量，它用来指示JVM如何搜索`class`
    - JVM需要知道，如果要加载一个`abc.xyz.Hello`的类，应该去哪搜索对应的`Hello.class`文件
    - 所以，`classpath`就是一组目录的集合，它设置的搜索路径与操作系统相关
  - 设定方法
    - 在系统环境变量中设置`classpath`环境变量，不推荐，会污染整个系统环境
    - 在启动JVM时设置`classpath`变量，给`java`命令传入`-classpath`或`-cp`参数，推荐
    - 在IDE中运行Java程序，IDE自动传入的`-cp`参数是当前工程的`bin`目录和引入的jar包
  - 补充
    - 没有设置系统环境变量，也没有传入`-cp`参数，那么JVM默认的`classpath`为`.`，即当前目录
    - 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！
    - 更好的做法是，不要设置`classpath`！默认的当前目录`.`对于绝大多数情况都够用了

- jar 包

  - 简介

    - jar 包可以把`package`组织的目录层级，以及各个目录下的所有文件（包括`.class`文件和其他文件）都打成一个jar文件
    - jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录
    - 如果我们要执行一个jar包的`class`，就可以把jar包放到`classpath`中

  - 制作

    - 因为jar包就是zip包，所以，直接在资源管理器中，制作一个zip文件，然后，把后缀从`.zip`改为`.jar`，一个jar包就创建成功
    - 注意：jar包里的第一层目录，不能是`bin`，而应该是`hong`、`ming`、`mr`，因为`hong.Person`必须按`hong/Person.class`存放，而不是`bin/hong/Person.class`

  - `MANIFEST.MF`

    - jar包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件，`MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息

    - JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令

      - ```shell
        $ java -jar hello.jar
        ```

    - jar包还可以包含其它jar包，这个时候，就需要在`MANIFEST.MF`文件里配置`classpath`

    - 在大型项目中，不可能手动编写`MANIFEST.MF`文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如[Maven](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)，可以非常方便地创建jar包

#### 12. 模块

- 发展

  - jar 包
    - jar只是用于存放class的容器，它并不关心class之间的依赖
    - 如果是自己开发的程序，除了一个自己的`app.jar`以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，需要把运行时需要用到的 jar 都写在 `-cp` 参数里
    - 从Java 9开始引入的模块，主要是为了解决“依赖”这个问题
  - 模块
    - 自带“依赖关系”的class容器就是模块
    - 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）
    - 此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本

- 编写模块

  - 描述文件

    - 在`src`目录下多了一个`module-info.java`这个文件，这就是模块的描述文件

    - ```java
      module <module-name> {
          exports com.itranswarp.sample;
      	requires java.base; // 可不写，任何模块都会自动引入java.base
      	requires java.xml;
      }
      ```

    - `module`是关键字，后面的`hello.world`是模块的名称，它的命名规范与包一致

    - 当我们使用模块声明了依赖关系后，才能在类中使用引入的模块

  - 编译

    - 与普通编译一样

    - ```shell
      $ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java
      ```

  - jar 包

    - 在打包的时候，注意传入`--main-class`参数，让这个jar包能自己定位`main`方法所在的类
    
    - ```shell
      $ jar --create --file <jar-name>.jar --main-class com.itranswarp.sample.Main -C bin .
      ```

  - 模块

    - ```shell
      $ jmod create --class-path <jar-name>.jar <jmod-name>.jmod
      ```

    - `<jar-name>` 与 `<jmod-name>` 一般一致

- 使用模块

  - 直接运行

    - ```shell
      $ java --module-path <jar-name>.jar --module <module-name>
      ```

    - 注意：`.jmod`不能被放入`--module-path`中，换成`.jar`就没问题了

  - 打包 jre

    - 制作自己的运行时环境

    - ```shell
      $ jlink --module-path <jmod-name>.jmod --add-modules java.base,java.xml,<module-name> --output jre/
      ```

    - 运行

    - ```shell
      $ jre/bin/java --module <module-name>
      ```

    - 要分发我们自己的Java应用程序，只需要把这个`jre`目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署

- 访问权限

  - 模块内部
    - Java的class访问权限分为public、protected、private和默认的包访问权限，这些访问权限只在一个模块内有效
  - 模块之间
    - 模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包
    - 模块进一步隔离了代码的访问权限



### 2. 核心类

#### 1. 字符串和编码

- String

  - 创建

    - ```java
      String s1 = "Hello!";
      String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'});
      ```

    - 注意：Java字符串的一个重要特点就是字符串不可变

  - 比较

    - 两个字符串比较，必须总是使用`equals()`方法
    - 要忽略大小写比较，使用`equalsIgnoreCase()`方法

- 常用方法

  - 搜索

      - ```java
        "Hello".contains("ll"); // true
        "Hello".indexOf("l"); // 2
        "Hello".lastIndexOf("l"); // 3
        "Hello".startsWith("He"); // true
        "Hello".endsWith("lo"); // true
        ```

  - 提取
  
      - ```java
        "Hello".substring(2); // "llo"
          "Hello".substring(2, 4); "ll"
        ```
  
  - 空白字符处理
  
      - ```java
          "  \tHello\r\n ".trim(); // "Hello"
          // 类似中文的空格字符\u3000也会被移除
          "\u3000Hello\u3000".strip(); // "Hello"
          " Hello ".stripLeading(); // "Hello "
          " Hello ".stripTrailing(); // " Hello"
          // 判断字符串是否为空和空白字符串
          "".isEmpty(); // true，因为字符串长度为0
          "  ".isEmpty(); // false，因为字符串长度不为0
          "  \n".isBlank(); // true，因为只包含空白字符
          " Hello ".isBlank(); // false，因为包含非空白字符
          ```
  
  - 替换
  
      - ```java
          // 一一对应
          String s = "hello";
          s.replace('l', 'w'); // "hewwo"，所有字符'l'被替换为'w'
          s.replace("ll", "~~"); // "he~~o"，所有子串"ll"被替换为"~~"
          // 正则表达式
          String s = "A,,B;C ,D";
          s.replaceAll("[\\,\\;\\s]+", ","); // "A,B,C,D"
          ```
  
  - 分割
  
      - ```java
          String s = "A,B,C,D";
          String[] ss = s.split("\\,"); // {"A", "B", "C", "D"}
          ```
  
  - 拼接
  
      - ```java
          String[] arr = {"A", "B", "C"};
          String s = String.join("***", arr); // "A***B***C"
          ```
  
  - 格式化
  
      - ```java
          String s = "Hi %s, your score is %d!";
          System.out.println(s.formatted("Alice", 80));
          System.out.println(String.format("Hi %s, your score is %.2f!", "Bob", 59.5));
          ```
  
  - 类型转换
  
      - ```java
          String.valueOf(123); // "123"
          String.valueOf(45.67); // "45.67"
          String.valueOf(true); // "true"
          String.valueOf(new Object()); // 类似java.lang.Object@636be97c
          ```
        
      - ```java
          // int
          int n1 = Integer.parseInt("123"); // 123
          int n2 = Integer.parseInt("ff", 16); // 按十六进制转换，255
          // boolean
          boolean b1 = Boolean.parseBoolean("true"); // true
          boolean b2 = Boolean.parseBoolean("FALSE"); // false
          // 注意：getInteger 方法是把该字符串对应的系统变量转换为 Integer
          Integer.getInteger("java.version"); // 版本号，11
          // char[]
          // 补充：修改 char[] 并不影响 string 的内容
          char[] cs = "Hello".toCharArray(); // String -> char[]
          String s = new String(cs); // char[] -> String
          ```
  
- 字符编码

  - ASCII

    - 一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从`0`到`127`，最高位始终为`0`

  - GB2312

    - 使用两个字节表示一个汉字，其中第一个字节的最高位始终为`1`，以便和`ASCII`编码区分开

  - Unicode

    - 需要两个或者更多字节表示
    - 英文字符的`Unicode`编码就是简单地在前面添加一个`00`字节

  - UTF-8

    - 一种变长编码，用来把固定长度的`Unicode`编码变成1～4字节的变长编码
    - `UTF-8`编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为`UTF-8`编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码

  - Java

    - 在Java中，`char`类型实际上就是两个字节的`Unicode`编码

    - ```java
      byte[] b1 = "Hello".getBytes(); // 按系统默认编码转换，不推荐
      byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
      byte[] b2 = "Hello".getBytes("GBK"); // 按GBK编码转换
      byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
      ```

    - ```java
      byte[] b = ...
      String s1 = new String(b, "GBK"); // 按GBK转换
      String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
      ```

#### 2. StringBuilder

- 简介

  - `StringBuilder`是可变对象，用来高效拼接字符串

  - ```java
    StringBuilder sb = new StringBuilder(1024);
    sb.append("Mr ")
        .append("Bob")
        .append("!")
        .insert(0, "Hello, ");
    String s = sb.toString();
    ```

- 链式操作

  - `StringBuilder`可以支持链式操作，实现链式操作的关键是返回实例本身

- StringBuffer

  - `StringBuffer`是`StringBuilder`的线程安全版本，现在很少使用

#### 3. StringJoiner

- 用分隔符拼接数组

- ```java
  String[] names = {"Bob", "Alice", "Grace"};
  var sj_1 = new StringJoiner(", ");
  for (String name : names) {
      sj_1.add(name);
  } // Bob, Alice, Grace
  var sj_2 = new StringJoiner(", ", "Hello ", "!");
  for (String name : names) {
      sj_2.add(name);
  } // Hello Bob, Alice, Grace!
  var s = String.join(", ", names); // Bob, Alice, Grace
  ```

#### 4. 包装类型

- 简介
  
  - Java核心库提供的包装类型可以把基本类型包装为`class`
- 自动转换
  - 直接把`int`变为`Integer`的赋值写法，称为自动装箱（Auto Boxing），反过来，把`Integer`变为`int`的赋值写法，称为自动拆箱（Auto Unboxing）
  - 自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码
  - 但是装箱和拆箱会影响代码的执行效率，而且自动拆箱执行时可能会报`NullPointerException`
- 不变性
  - 所有的包装类型都是不变类
  - 包装类型的比较必须使用`equals()`
- 创建
  - 在我们自己创建`Integer`的时候，以下两种方法
    - 方法1：`Integer n = new Integer(100);`
    - 方法2：`Integer n = Integer.valueOf(100);`
  - 方法2更好，因为方法1总是创建新的`Integer`实例，方法2把内部优化留给`Integer`的实现者去做
  - 我们把能创建“新”对象的静态方法称为静态工厂方法

- 常用方法

  - 字符串转换，进制转换

    - ```java
      int x1 = Integer.parseInt("100"); // 100
      int x2 = Integer.parseInt("100", 16); // 256,因为按16进制解析
      System.out.println(Integer.toString(100)); // "100",表示为10进制
      System.out.println(Integer.toString(100, 36)); // "2s",表示为36进制
      System.out.println(Integer.toHexString(100)); // "64",表示为16进制
      System.out.println(Integer.toOctalString(100)); // "144",表示为8进制
      System.out.println(Integer.toBinaryString(100)); // "1100100",表示为2进制
      ```

    - 上述方法的输出都是`String`，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法

    - 这体现了程序设计的一个重要原则：数据的存储和显示要分离

  - 静态变量

    - ```java
      // boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:
      Boolean t = Boolean.TRUE;
      Boolean f = Boolean.FALSE;
      // int可表示的最大/最小值:
      int max = Integer.MAX_VALUE; // 2147483647
      int min = Integer.MIN_VALUE; // -2147483648
      // long类型占用的bit和byte数量:
      int sizeOfLong = Long.SIZE; // 64 (bits)
      int bytesOfLong = Long.BYTES; // 8 (bytes)
      ```

  - 父类 Number

    - ```java
      // 向上转型为Number:
      Number num = new Integer(999);
      // 获取byte, int, long, float, double:
      byte b = num.byteValue();
      int n = num.intValue();
      long ln = num.longValue();
      float f = num.floatValue();
      double d = num.doubleValue();
      ```

  - 无符号整型

    - ```java
      byte x = -1;
      byte y = 127;
      System.out.println(Byte.toUnsignedInt(x)); // 255
      System.out.println(Byte.toUnsignedInt(y)); // 127
      ```

#### 5. JavaBean

- 定义
  - JavaBean是一种符合命名规范的`class`，它通过`getter`和`setter`来定义属性
- 属性
  - 我们通常把一组对应的读方法（`getter`）和写方法（`setter`）称为属性（`property`）。例如，`name`属性
    - 对应的读方法是`String getName()`
    - 对应的写方法是`setName(String)`
  - 属性只需要定义`getter`和`setter`方法，不一定需要对应的字段
- 作用
  - JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输
  - 此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中
- 查看
  - 要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的`Introspector.getBeanInfo()`

#### 6. 枚举类

- 传统常量的使用

  - 使用 `static final` 常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性

- enum

  - ```java
    enum Weekday {
        SUN, MON, TUE, WED, THU, FRI, SAT;
    }
    ```

- 优势

  - `enum`常量本身带有类型信息，即`Weekday.SUN`类型是`Weekday`，编译器会自动检查出类型错误
  - 不可能引用到非枚举的值，因为无法通过编译
  - 不同类型的枚举不能互相比较或者赋值，因为类型不符

- 比较

  - 引用类型比较，要始终使用`equals()`方法，但`enum`类型可以例外
  - 这是因为`enum`类型的每个常量在JVM中只有一个唯一实例，所以可以直接用`==`比较

- 区别

  - 定义的`enum`类型总是继承自`java.lang.Enum`，且无法被继承
  - 只能定义出`enum`的实例，而无法通过`new`操作符创建`enum`的实例
  - 定义的每个实例都是引用类型的唯一实例
  - 可以将`enum`类型用于`switch`语句
  - 补充：我们自己无法按定义普通`class`那样来定义`enum`，必须使用`enum`关键字，这是Java语法规定的

- 方法

  - name()

    - ```java
      // 返回常量名
      String s = Weekday.SUN.name(); // "SUN"
      ```

    - 默认情况下，对枚举常量调用`toString()`会返回和`name()`一样的字符串。但是，`toString()`可以被覆写，而`name()`则不行
    - 判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()

  - ordinal()

    - ```java
      // 返回定义的常量的顺序，从0开始计数
      int n = Weekday.MON.ordinal(); // 1
      ```

    - 改变枚举常量定义的顺序就会导致`ordinal()`返回值发生变化

    - 要编写健壮的代码，就不要依靠`ordinal()`的返回值

- 构造方法

  - 因为`enum`本身是`class`，所以我们可以定义`private`的构造方法，并且，给每个枚举常量添加字段

  - ```java
    enum Weekday {
        MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);
    
        // 枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做
        public final int dayValue;
    
        private Weekday(int dayValue) {
            this.dayValue = dayValue;
        }
    }
    ```

#### 7. 记录类

- 不变类

  - 特点
    - 定义class时使用`final`，无法派生子类
    - 每个字段使用`final`，保证创建实例后无法修改任何字段
  - 举例
    - `String`、`Integer`

- record

  - 从Java 14开始，提供新的`record`关键字，可以非常方便地定义Data Class

  - ```java
    public record Point(int x, int y) {}
    ```

  - 除了用`final`修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写`toString()`、`equals()`和`hashCode()`方法

  - 和`enum`类似，我们自己不能直接从`Record`派生，只能通过`record`关键字由编译器实现继承

- 构造方法

  - 可以编写Compact Constructor对参数进行验证

- 静态方法

  - 一种常用的静态方法是`of()`方法，用来创建`Point`

#### 8. BigInteger

- 使用

  - 在Java中，由CPU原生提供的整型最大范围是64位`long`型整数

  - `BigInteger`内部用一个`int[]`数组来模拟一个非常大的整数

  - ```java
    BigInteger bi = new BigInteger("1234567890");
    ```

- 运算

  - 对`BigInteger`做运算的时候，只能使用实例方法

- 转换

  - `BigInteger`和`Integer`、`Long`一样，也是不可变类，并且也继承自`Number`类，所以可以使用`Number`定义的转换为基本类型的方法
  - `IntValue()`
    - 如果`BigInteger`表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的
    - 补充：如果`BigInteger`的值甚至超过了`float`的最大范围（3.4x1038），那么 `floatValue()` 返回的float是 `Infinity`
  - `intValueExact()`
    - 在转换时如果超出范围，将直接抛出`ArithmeticException`异常

#### 9. BigDecimal

- 使用

  - 和`BigInteger`类似，`BigDecimal`可以表示一个任意大小且精度完全准确的浮点数，常用于财务计算

  - ```java
    BigDecimal bd = new BigDecimal("123.4567");
    ```

  - `BigDecimal`也是从`Number`继承的，也是不可变对象

- 常用方法

  - scale()
    - 表示小数位数
    - 如果一个`BigDecimal`的`scale()`返回负数，例如，`-2`，表示这个数是个整数，并且末尾有2个0
  - stripTrailingZeros()
    - 将一个`BigDecimal`格式化为一个相等的，但去掉了末尾0的`BigDecimal`
  - setScale()
    - 可以对一个`BigDecimal`设置它的`scale`，如果精度比原始值低，那么必须指定进行四舍五入 `RoundingMode.HALF_UP` 或者直接截断 `RoundingMode.DOWN`

- 运算

  - 加、减、乘
    - 对`BigDecimal`做加、减、乘时，精度不会丢失
  - 除法
    - 但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断，否则抛出异常 `ArithmeticException`
  - 除法 + 求余
    - divideAndRemainder()
    - 返回的数组包含两个`BigDecimal`，分别是商和余数，其中商总是整数，余数不会大于除数
    - 我们可以利用这个方法判断两个`BigDecimal`是否是整数倍数

- 比较

  - equals()
    - 使用`equals()`方法不但要求两个`BigDecimal`的值相等，还要求它们的`scale()`相等
  - compareTo()
    - 根据两个值的大小分别返回负数、正数和`0`，分别表示小于、大于和等于
  - 注意：总是使用compareTo()比较两个BigDecimal的值，不要使用equals()

#### 10. 常用工具类

- Math
  - 用来进行数学计算
  - `StrictMath`保证所有平台计算（例如x86和ARM）结果都是完全相同的，而`Math`会尽量针对平台优化计算速度，所以，绝大多数情况下，使用`Math`就足够了
- Random
  - 用来创建伪随机数
  - 所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的
  - `Math.random()`实际上内部调用了`Random`类，所以它也是伪随机数，只是我们无法指定种子
- SecureRandom
  - 用来创建一个不可预测的安全的随机数



## 第三章 异常处理

#### 1. Java 的异常

- 发展
  - 所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错
  - 调用方如何获知调用失败的信息？有两种方法
    - 方法一：约定返回错误码
      - 常见于底层C函数
    - 方法二：在语言层面上提供一个异常处理机制
- 定义
  - Java的异常是`class`，`Throwable`是异常体系的根，它继承自`Object`
- 分类
  - `Error`：表示严重的错误，程序对此一般无能为力
  - `Exception`：运行时的错误，它可以被捕获并处理
    - `RuntimeException`
    - 非 `RuntimeException` 
- 分类 2
  - 必须捕获的异常
    - 包括`Exception`及其子类，但不包括`RuntimeException`及其子类，这种类型的异常称为Checked Exception
    - 如果程序中没有捕获语句则会出现编译失败
  - 不需要捕获的异常
    - 包括`Error`及其子类，`RuntimeException`及其子类
    - 编译器不做强制要求，但是是否需要捕获需要具体分析
- 捕获异常
  - 在方法定义的时候，使用`throws Xxx`表示该方法可能抛出的异常类型
  - 只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获，或者抛出

#### 2. 捕获异常

- catch 语句
  - 可以使用多个`catch`语句，每个`catch`分别捕获对应的`Exception`及其子类
  - 匹配到某个`catch`后，执行`catch`代码块，然后不再继续匹配
  - 因此，存在多个`catch`的时候，`catch`的顺序非常重要，子类必须写在前面
- finally 语句
  - `finally`语句块保证有无错误都会执行
  - 特点
    - `finally`语句不是必须的，可写可不写
    - `finally`总是最后执行
  - 某些情况下，可以没有`catch`，只使用`try ... finally`结构
- 捕获多种异常
  - 如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条`catch`子句
  - 我们可以把多个异常类型用`|`合并到一起

#### 3. 抛出异常

- 异常的传播
  - 通过`printStackTrace()`可以打印出方法的调用栈
- 抛出异常
  - 创建某个`Exception`的实例
  - 用`throw`语句抛出
- 异常的转换
  - 定义
    - 如果一个方法捕获了某个异常后，又在`catch`子句中抛出新的异常，就相当于把抛出的异常类型“转换”了
  - 注意
    - 新的异常丢失了原始异常信息
    - 为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息
  - 查看
    - 在代码中获取原始异常可以使用`Throwable.getCause()`方法。如果返回`null`，说明已经是“根异常”了
- finally 的执行顺序
  - 在同一个代码块中，throw 之后的语句都不会被执行
  - 但是，在 finally 中的语句除外，程序总会执行完 finally 之后才抛出异常
- 异常屏蔽
  - 定义
    - 如果在 finally 中有抛出异常，则原来在 catch 中准备抛出的异常就“消失”了
    - 没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）
  - 处理方法
    - 如果要保存被屏蔽的异常，需要先用变量保存原始异常，然后调用`Throwable.addSuppressed()`，把原始异常添加进来
    - 通过`Throwable.getSuppressed()`可以获取所有的`Suppressed Exception`
  - 注意
    - 因此，绝大多数情况下，在`finally`中不要抛出异常

#### 4. 自定义异常

- 抛出异常时，尽量复用JDK已定义的异常类型
- 自定义异常体系时，推荐从`RuntimeException`派生“根异常”，再派生出业务异常
- 自定义异常时，应该提供多种构造方法

#### 5. NullPointerException

- 定义
  - 如果一个对象为`null`，调用其方法或访问其字段就会产生`NullPointerException`
  - 属于 `RuntimeException`
- 处理
  - `NullPointerException`是Java代码常见的逻辑错误，应当早暴露，早修复
  - 可以启用Java 14的增强异常信息来查看`NullPointerException`的详细错误信息

#### 6. 断言

- 定义

  - 断言（Assertion）是一种调试程序的方式，在Java中，使用`assert`关键字来实现断言

  - 断言成功，则程序正常运行，断言失败，抛出`AssertionError`

  - ```java
    assert x >= 0 : "x must >= 0";
    ```

- 使用

  - 断言失败时会抛出`AssertionError`，导致程序结束退出
  - 因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段
  - 对于可恢复的程序错误，不应该使用断言

- 注意

  - 要执行`assert`语句，必须给Java虚拟机传递`-enableassertions`（可简写为`-ea`）参数启用断言
  - 实际开发中，很少使用断言，更好的方法是编写单元测试 `JUnit`

#### 7. JDK Logging

- 定义

  - 日志就是Logging，它的目的是为了取代`System.out.println()`

- 优势

  - 可以设置输出样式，自动打印时间、调用类、调用方法等很多有用的信息
  - 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志
  - 可以被重定向到文件，这样可以在程序运行结束后查看日志
  - 可以按包名控制日志级别，只输出某些包打的日志

- 使用

  - Java标准库内置了日志包`java.util.logging`

  - ```java
    Logger logger = Logger.getGlobal();
    logger.info("start process...");
    logger.warning("memory is running out...");
    ```

  - 7 个日志级别

    - SEVERE
    - WARNING
    - INFO
    - CONFIG
    - FINE
    - FINER
    - FINEST

  - 默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来

- 问题

  - Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行`main()`方法，就无法修改配置
  - 配置不太方便，需要在JVM启动时传递参数`-Djava.util.logging.config.file=<config-file-name>`

#### 8. Commons Logging

- 简介

  - Commons Logging是一个第三方日志库，它是由Apache创建的日志模块
  - 是使用最广泛的日志模块，API 简单，还可以自动检测并使用其他日志模块
  - 特色是可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统
  - 默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging

- 通用使用

  - 第一步，通过`LogFactory`获取`Log`类的实例

  - 第二步，使用`Log`实例的方法打日志

  - ```java
    Log log = LogFactory.getLog(Main.class);
    log.info("start...");
    log.warn("end.");
    ```

  - 6 个日志级别，默认级别是`INFO`

    - FATAL
    - ERROR
    - WARNING
    - INFO
    - DEBUG
    - TRACE

  - Commons Logging的日志方法，例如`info()`，除了标准的`info(String)`外，还提供了一个非常有用的重载方法：`info(String, Throwable)`，这使得记录异常更加简单

- 使用

  - 静态方法

    - 通常直接定义一个静态类型变量

    - ```java
      static final Log log = LogFactory.getLog(Main.class);
      ```

  - 实例方法

    - 通常定义一个实例变量

    - ```java
      protected final Log log = LogFactory.getLog(getClass());
      ```

    - 注意：可以使用 `<Class-Name>.class` 代替 `getClass()`， 但这种写法的好处在于，子类可以直接使用该`log`实例，无需改动代码

#### 9. Log4j

- 简介
  - 前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j
- 构件
  - Appender
    - 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地
  - Filter
    - 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出
  - Layout
    - 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息
  - 目的地
    - console：输出到屏幕
    - file：输出到文件
    - socket：通过网络输出到远程计算机
    - jdbc：输出到数据库
- 使用
  - 配置文件
    - 把一个`log4j2.xml`的文件放到`classpath`下就可以让Log4j读取配置文件并按照我们的配置来输出日志
  - 依赖包
  - 调用 Commons Logging
    - 因为Commons Logging会自动发现并使用Log4j，所以要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出
- 编程规范
  - 在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j
  - 如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入`classpath`，就可以自动把日志切换成使用Log4j写入，无需修改任何代码

#### 10. SLF4J 和 Logback

- 简介
  - SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现
  - Java有着非常悠久的开源历史，开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库
  - 因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback

