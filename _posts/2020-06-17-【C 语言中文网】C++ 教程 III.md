---
layout: post
title:  【C 语言中文网】C++ 教程笔记 第三部分
date:   2020-06-17
categories: C++
---



### 第九章 面向对象进阶

#### 1. 拷贝构造函数

- 当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）
- 拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用
  - 引用：不仅是逻辑上的要求，也是 C++ 语法的要求
  - const：添加 const 限制后，可以将 const 对象和非 const 对象传递给形参
- 默认拷贝构造函数
  - 如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值

#### 2. 拷贝构造函数：何时调用

- 在定义的同时进行赋值叫做初始化（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）。初始化只能有一次，赋值可以有多次

- 以拷贝的方式初始化对象

  - 将其它对象作为实参：`Student stu2(stu1);  //以拷贝的方式初始化`

  - 在创建对象的同时赋值：`Student stu2 = stu1;  //以拷贝的方式初始化`

  - 函数的形参为类类型

    - ```c++
      void func(Student s){
        //TODO:
      }
      Student stu("小明", 16, 90.5);  //普通初始化
      func(stu);  //以拷贝的方式初始化
      ```

  - 函数返回值为类类型

    - ```c++
      Student func(){
        Student s("小明", 16, 90.5);
        return s;
      }
      Student stu = func();
      ```

#### 3. 深拷贝和浅拷贝

- 浅拷贝
  - 按位复制内存
  - 默认的拷贝构造函数
- 深拷贝
  - 将对象所持有的其它资源一并拷贝
  - 必须显式地定义拷贝构造函数
- 何时需要深拷贝
  - 如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，如果类的成员变量没有指针，一般浅拷贝足以
  - 另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等

#### 4. 重载 `=`

- 初始化与赋值
  - 初始化
    - 在定义的同时进行赋值叫做初始化
    - 初始化只能有一次
    - 当以拷贝的方式初始化一个对象时，会调用拷贝构造函数
  - 赋值
    - 定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值
    - 赋值可以有多次
    - 当给一个对象赋值时，会调用重载过的赋值运算符
    - 即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似
- 注意
  - operator=() 的返回值类型为`Array &`，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的
  - `if( this != &arr)`语句的作用是「判断是否是给同一个对象赋值」
  - `return *this`表示返回当前对象（新对象）
  - operator=() 的形参类型为`const Array &`，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收 const 类型和非 const 类型的实参
  - 赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值

#### 5. 拷贝控制操作

- 拷贝控制操作
  - 拷贝
    - 拷贝构造函数
    
    - ```c++
      Array(const Array &arr);
      ```
    
    - 定义了当用同类型的另一个对象初始化新对象时做什么
  - 赋值
    - 赋值运算符
    
    - ```c++
      Array & operator=(const Array &arr);
      ```
    
    - 定义了将一个对象赋予同类型的另一个对象时做什么
  - 销毁
    - 析构函数
    
    - ```c++
      ~Array();
      ```
    
    - 定义了此类型的对象销毁时做什么
- C++ 三/五法则
  - C++89 标准：由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”
  - C++11 标准：在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”
- 原则
  - `析构 => 拷贝 + 赋值`：需要析构函数的类也需要拷贝和赋值操作
  - `拷贝 <=> 赋值`：需要拷贝操作的类也需要赋值操作，然而，无论需要拷贝构造函数还是需要复制运算符，都不必然意味着也需要析构函数

#### 6. 类型转换：转换构造函数

- 类型转换

  - 自动类型转换（隐式类型转换）
  - 强制类型转换
  - C++ 允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。这种自定义的类型转换规则只能以类的成员函数的形式出现，换句话说，这种转换规则只适用于类

- 转换构造函数

  - 将其它类型转换为当前类类型，只有一个参数

  - ```c++
    Complex c1(26.4);  //创建具名对象
    Complex c2 = 240.3;  //以拷贝的方式初始化对象
    Complex(15.9);  //创建匿名对象
    c2 = c1 + 29.6;  // 编译器先将 29.6 转换为 Complex 类型再相加
    ```

  - 多级类型转换
  
    - 需要注意的是，为了获得目标类型，编译器会“不择手段”，会综合使用内置的转换规则和用户自定义的转换规则，并且会进行多级类型转换，
  
    - ```c++
      Complex c1 = 100;  //int --> double --> Complex
      c1 = 'A';  //char --> int --> double --> Complex
      c1 = true;  //bool --> int --> double --> Complex
      ```
  
- 回顾：构造函数

  - 分类

    - 默认构造函数
    - 普通构造函数
    - 拷贝构造函数
    - 转换构造函数

  - 合并

    - 不同类型的构造函数本质都是构造函数，只是称呼不同，可以借助[函数的默认参数](http://c.biancheng.net/view/2204.html)将三个构造函数简化为一个（不包括拷贝构造函数）

    - ```c++
      Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
      ```

    - ```c++
      Complex a(10.0, 20.0);  //向构造函数传递 2 个实参，不使用默认参数
      Complex b(89.5);  //向构造函数传递 1 个实参，使用 1 个默认参数
      Complex c;  //不向构造函数传递实参，使用全部默认参数
      a = 25.5;  //调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数）
      ```

#### 7. 类型转换：类型转换函数

- 简介

  - 类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中

  - 类型转换函数和运算符的重载非常相似，都使用 operator 关键字，因此也把类型转换函数称为类型转换运算符

  - ```c++
    operator type() const { return data; }
    ```

- 注意

  - 类型转换函数不需要写返回值类型，因为已经隐式地指明了返回值类型
  - 类型转换函数也没有参数，只有一个隐式的 this 参数
  - 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员

- 说明

  - type 可以是内置类型、类类型以及由 typedef 定义的类型别名（void 除外），一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的
  - 类型转换函数可以被继承，可以是虚函数
  - 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性

#### 8. 类型转换：二义性

- 起因
  - 转换构造函数和类型转换函数的作用是相反的：转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型
  - 但是，如果一个类同时存在这两个函数，就有可能产生二义性
- 解决办法
  - 解决二义性问题的办法也很简单粗暴，要么只使用转换构造函数，要么只使用类型转换函数
  - 实践证明，用户对转换构造函数的需求往往更加强烈，这样能增加编码的灵活性
  - 增加一个普通的成员函数即可代替类型转换函数，例如，string 类使用 c_str() 函数转换为 C 风格的字符串，complex 类使用 real() 和 imag() 函数来获取复数的实部和虚部

#### 9. 类型转换：本质

- 类型
  - 隐式类型转换（自动类型转换）
    - 隐式类型转换除了会重新解释数据的二进制位，还会利用**<u>已知的转换规则</u>**对数据进行恰当地调整
    - 隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）
  - 强制类型转换
    - 显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整
    - 强制类型转换能够在更大范围的数据类型之间进行转换，这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用
- 说明
  - 强制类型转换的语法其实是没有必要的，编译器完全可以自行判断是否需要调整数据
  - C/C++ 之所以增加强制类型转换的语法，是为了提醒程序员这样做存在风险，一定要谨慎小心
  - 类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行
    - 两个没有继承关系的类不能相互转换
    - 基类不能向派生类转换（向下转型）
    - 类类型不能向基本类型转换
    - 指针和类类型之间不能相互转换

#### 10. 类型转换：运算符 xxx_cast

- 类型转换运算符

  | 关键字           | 说明                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | static_cast      | 用于良性转换，一般不会导致意外发生，风险很低。               |
  | const_cast       | 用于 const 与非 const、volatile 与非 volatile 之间的转换。   |
  | reinterpret_cast | 高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。 |
  | dynamic_cast     | 借助 RTTI，用于类型安全的向下转型（Downcasting）。           |
  - 语法格式

    - ```c++
      xxx_cast<newType>(data)
      ```

  - 目的

    - 使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范

- static_cast
  - 原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等
  - void [指针](http://c.biancheng.net/c/80/)和具体类型指针之间的转换，例如`void *`转`int *`、`char *`转`void *`等
  - 有转换构造函数或者类型转换函数的类与其它类型之间的转换
  - 不能用于两个具体类型指针之间的转换，例如`int *`转`double *`、`Student *`转`int *`等
  - 不能用于int 和指针之间的转换
- const_cast
  
  - 用来将 const/volatile 类型转换为非 const/volatile 类型，例如 const int * 转 int *
- reinterpret_cast
  
  - 仅仅是对二进制位的重新解释，例如两个具体类型指针之间的转换、int 和指针之间的转换
- dynamic_cast
  - dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数
  - dynamic_cast 只能转换指针类型和引用类型
  - 向上转型
    - 向上转型是无条件的，不会进行任何运行期间的检查，相当于 static_cast
  - 向下转型
    - dynamic_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功
    - 从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的



### 第十章 输入输出流

- C++输入输出流本质上就是已经定义好的类对象

#### 1. 简介

- 回顾：C 语言中的 I/O

  - 使用 scanf()、gets() 等函数从键盘读取数据，使用 printf()、puts() 等函数向屏幕上输出数据
  - 使用 fscanf()、fgets() 等函数读取文件中的数据，使用 fprintf()、fputs() 等函数向文件中写入数据

- 输出流

  - ostream 类对象：cout、cerr 和 clog

    |      | 重定向 | 缓冲区 |
    | ---- | ------ | ------ |
    | cout | 支持   | 有     |
    | cerr | 不支持 | 没有   |
    | clog | 不支持 | 有     |

    | 成员方法名 | 功能                                             |
    | ---------- | ------------------------------------------------ |
    | put()      | 输出单个字符。                                   |
    | write()    | 输出指定的字符串。                               |
    | tellp()    | 用于获取当前输出流指针的位置。                   |
    | seekp()    | 设置输出流指针的位置。                           |
    | flush()    | 刷新输出流缓冲区。                               |
    | operator<< | 重载 << 运算符，使其用于输出其后指定类型的数据。 |

- 输入流

  - istream 类对象：cin

    | 成员方法名        | 功能                                                         |
    | ----------------- | ------------------------------------------------------------ |
    | getline(str,n,ch) | 从输入流中接收 n-1 个字符给 str 变量，当遇到指定 ch 字符时会停止读取，默认情况下 ch 为 '\0'。 |
    | get()             | 从输入流中读取一个字符，同时该字符会从输入流中消失。         |
    | gcount()          | 返回上次从输入流提取出的字符个数，该函数常和 get()、getline()、ignore()、peek()、read()、readsome()、putback() 和 unget() 联用。 |
    | peek()            | 返回输入流中的第一个字符，但并不是提取该字符。               |
    | putback(c)        | 将字符 c 置入输入流（缓冲区）。                              |
    | ignore(n,ch)      | 从输入流中逐个提取字符，但提取出的字符被忽略，不被使用，直至提取出 n 个字符，或者当前读取的字符为 ch。 |
    | operator>>        | 重载 >> 运算符，用于读取指定类型的数据，并返回输入流对象本身。 |

#### 2. ostream：单个字符

- ```c++
  ostream& put(char c); // c++
  putchar(char c) // c
  ```

#### 3. ostream：字符串

- ```c++
  // s 用于指定某个长度至少为 n 的字符数组或字符串；n 表示要输出的前 n 个字符
  ostream& write(const char * s，streamsize n);
  ```

#### 4. ostream：操作缓冲区

- 简介

  - 回顾：无论是使用 cout 输出普通数据，用 cout.put() 输出指定字符，还是用 cout.write() 输出指定字符串，数据都会先放到输出流缓冲区，待缓冲区刷新，数据才会输出到指定位置（屏幕或者文件中）
  - ostream 类中提供有 tellp() 和 seekp() 成员方法，借助它们就可以修改位于输出流缓冲区中的数据

- tellp()

  - tellp() 成员方法用于获取当前输出流缓冲区中最后一个字符所在的位置

  - ```c++
    streampos tellp();
    ```

  - 当输出流缓冲区中没有任何数据时，该函数返回的整形值为 0；当指定的输出流缓冲区不支持此操作，或者操作失败时，该函数返回的整形值为 -1

- seekp

  - seekp() 方法用于指定下一个进入输出缓冲区的字符所在的位置，之后输入的新字符会覆盖缓冲区之前的旧字符

  - ```c++
    //指定下一个字符存储的位置
    ostream& seekp (streampos pos);
    //通过偏移量间接指定下一个字符的存储位置   
    ostream& seekp (streamoff off, ios_base::seekdir way);
    ```

#### 5. ostream：格式化输出

- 回顾：C 语言 printf() 函数
- 实现格式化输出的成员方法
- fmtfl 和 mask 参数可选值
- 流操纵算子：在 `<iomanip>` 头文件中定义

#### 6. 重定向

- freopen()

  - freopen() 定义在`<stdio.h>`头文件中，是 C 语言标准库中的函数，专门用于重定向输入流（包括 scanf()、gets() 等）和输出流（包括 printf()、puts() 等），该函数也可以对 C++ 中的 cin 和 cout 进行重定向

  - ```c++
    //将标准输入流重定向到 in.txt 文件
    freopen("in.txt", "r", stdin);
    //将标准输出重定向到 out.txt文件
    freopen("out.txt", "w", stdout); 
    ```

- rdbuf()

  - rdbuf() 函数定义在`<ios>`头文件中，专门用于实现 C++ 输入输出流的重定向

  - ```c++
    // 返回一个指向当前流缓冲区的指针
    streambuf * rdbuf() const;
    // 将 sb 指向的缓冲区设置为当前流的新缓冲区，并返回一个指向旧缓冲区的对象
    streambuf * rdbuf(streambuf * sb);
    ```

  - ```c++
    //打开 in.txt 文件，等待读取
    ifstream fin("in.txt");
    //用 rdbuf() 重新定向，返回旧输入流缓冲区指针
    streambuf *oldcin = cin.rdbuf(fin.rdbuf());
    //还原标准输入输出流
    cin.rdbuf(oldcin); // 恢复键盘输入
    ```

- 控制台

  - ```shell
    C:\Users\mengma>D:\demo.exe <in.txt >out.txt
    ```

#### 7. ostream：缓冲区

- 缓冲机制
  - 每个输出流都管理一个缓冲区，用来保存程序读写的数据
  - 有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。
  - 何时会刷新缓冲
    - 程序正常结束，作为 main() 函数的 return 操作的一部分，缓冲刷新被执行。
    - 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
    - 我们可以使用操纵符如 endl 来显式刷新缓冲区。
    - 在每个输出操作之后，我们可以用操作符 unitbuf 设置流的内部状态，来清空缓冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此写到 cerr 的内容都是立即刷新的。
    - 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin 和 cerr 都关联到 cout。因此，读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。
    
  - 注意：如果程序崩溃，输出缓冲区不会被刷新
  
- 管理缓冲区的刷新

  - 手动刷新一次
  
    - ```c++
      cout << "hi!" << endl;  //输出hi和一个换行，然后刷新缓冲区
      cout << "hi!" << flush;  //输出hi，然后刷新缓冲区，不附加任何额外字符
    cout << "hi!" << ends;  //输出hi和一个空字符，然后刷新缓冲区
      ```
  
  - 自动刷新：unitbuf 操作符
  
    - ```c++
     cout << unitbuf;  //所有输出操作后都会立即刷新缓冲区
    //任何输出都立即刷新，无缓冲
    cout << nounitbuf;  //回到正常的缓冲方式
      ```
  
  - 自动刷新：关联输入和输出流
  
    - 一个输出流 A 可能被关联到另一个输入或输出流 B，任何试图从流 B 读取/写入数据的操作都会先刷新流 A
  
    - 每个流同时最多关联到一个输出流， 但一个 ostream 可以被多个流同时关联
  
    - ```c++
      ostream* tie ( ) const;  //返回指向绑定的输出流的指针。
      ostream* tie ( ostream* os );  //将 os 指向的输出流绑定的该对象上，并返回上一个绑定的输出流指针。
      ```

#### 8. istream：单个字符

- ```c++
  // 此函数从输入流中读入一个字符，返回值就是该字符的 ASCII 码。如果碰到输入的末尾，则返回值为 EOF
  int get();
  ```

- EOF 是 End of File 的缩写。istream 类中从输入流（包括文件）中读取数据的成员函数，在把输入数据都读取完后再进行读取，就会返回 EOF。EOF 是在 iostream 类中定义的一个整型常量，值为 -1

- get() 函数不会跳过空格、制表符、回车等特殊字符，所有的字符都能被读入

#### 9. istream：字符串

- getline() 是 istream 类的成员函数

- 用 `cin >> str` 这种写法是不行的，因为此种读法在碰到行中的空格或制表符时就会停止，因此就不能保证 str 中读入的是整行

- ```c++
  istream & getline(char* buf, int bufSize);
  istream & getline(char* buf, int bufSize, char delim);
  ```

  - 第一个版本从输入流中读取 bufSize-1 个字符到缓冲区 buf，或遇到`\n`为止（哪个条件先满足就按哪个执行）。函数会自动在 buf 中读入数据的结尾添加`\0`
  - 第二个版本和第一个版本的区别在于，第一个版本是读到`\n`为止，第二个版本是读到 delim 字符为止。`\n`或 delim 都不会被读入 buf，但会被从输入流中取走

- 注意

  - 如果输入流中`\n`或 delim 之前的字符个数达到或超过 bufSize，就会导致读入出错，其结果是：虽然本次读入已经完成，但是之后的读入都会失败

  - ```c++
    cin.clear(); //clear能够清除cin内部的错误标记，使之恢复正常
    ```

  - getline() 函数的返回值为 false 则输入结束，true 则表示还有内容

#### 10. istream：忽略指定字符

- ```c++
  istream & ignore(int n =1, int delim = EOF);
  ```

- 此函数的作用是跳过输入流中的 n 个字符，或跳过 delim 及其之前的所有字符，哪个条件先满足就按哪个执行

#### 11. istream：查看下一个字符

- peek()
  - 此函数返回输入流中的下一个字符，但是并不将该字符从输入流中取走
  - cin.peek() 不会跳过输入流中的空格、回车符。在输入流已经结束的情况下，cin.peek() 返回 EOF
- get() + putback(c)
  - 也可以在用 get() 函数读取一个字符判断格式，再将刚刚读取的字符再用 putback() 成员函数放回流中

#### 12. istream：判断输入结束

- cin 返回值

  - 结束标志

    - 文件：文件末尾
    - 控制台：在 Windows 系统中为 Ctrl+Z；在 UNIX/Linux/Mac OS 系统中为 Ctrl+D

  - cin 在正常读取时返回 true，遇到结束标志时返回 false，我们可以根据 cin 的返回值来判断是否读取结束

  - ```c++
    int n;
    while (cin >> n){  //输入没有结束，cin 就返回 true，条件就为真
    }
    ```

  - 如果 cin 在读取过程中发生了错误，`cin>>n`这样的表达式也会返回 false

- 原理

  - istream 类对强制类型转换运算符 bool 进行了重载，这使得 cin 对象可以被自动转换成 bool 类型

#### 13. I/O 错误

- 流状态

  - C++ 将所有可能的错误情况归结为四类流状态，每种流状态都用一个 iostate 类型的标志位来表示

    | 标志位  | 意义                                                         | 检测函数 |
    | ------- | ------------------------------------------------------------ | -------- |
    | badbit  | 发生了（或许是物理上的）致命性错误，流将不能继续使用。       | bad()    |
    | eofbit  | 输入结束（文件流的物理结束或用户结束了控制台流输入，例如用户按下了 Ctrl+Z 或 Ctrl+D 组合键。 | eof()    |
    | failbit | I/O 操作失败，主要原因是非法数据（例如，试图读取数字时遇到字母）。流可以继续使用，但会设置 failbit 标志。 | fail()   |
    | goodbit | 一切止常，没有错误发生，也没有输入结束。                     | good()   |

- clear()

  - 无参数：清除流状态
  - 有参数：参数中所指出的 iostream 状态位会被置位，而未指出的状态位会被复位

- 抛出异常

  - 简单起见，可以设置让 istream 处于 bad() 状态时抛出这个异常

  - ```c++
    ist.exceptions(ist.exceptions() | ios_base:: badbit);
    ```

  - 当此语句执行时，如果 ist 处于 bad() 状态，它会抛出一个标准库异常 ios_base::failure

  - 在一个程序中，我们只需要调用 exceptions() 一次。这允许我们简化关联于 ist 的所有输入过程，同时忽略对 bad() 的处理



### 第十一章 文件操作

#### 1. 文件是什么

- 文本文件
- 二进制文件

#### 2. 文件流类

- ifstream：专用于从文件中读取数据；
- ofstream：专用于向文件中写入数据；
- fstream：既可用于从文件中读取数据，又可用于向文件中写入数据

#### 3. 打开文件

- open 成员函数

  - ```c++
    void open(const char* szFileName, int mode)
    ```

  - 第一个参数是指向文件名的[指针](http://c.biancheng.net/c/80/)，第二个参数是文件的打开模式标记

  - 调用 open 成员函数时，给出的文件名可以是绝对路径，也可以是相对路径

  - 文件打开模式标记

- 构造函数

  - ```c++
    ifstream::ifstream (const char* szFileName, int mode = ios::in, int);
    ```

  - 第一个参数是指向文件名的指针；第二个参数是打开文件的模式标记，默认值为`ios::in`; 第三个参数是整型的，也有默认值，一般极少使用

#### 4. 打开文件：打开方式

- 文本方式和二进制方式并没有本质上的区别，只是对于换行符的处理不同
- 总的来说，Linux 平台使用哪种打开方式都行；Windows 平台上最好用 "ios::in | ios::out" 等打开文本文件，用 "ios::binary" 打开二进制文件。但无论哪种平台，用二进制方式打开文件总是最保险的

#### 5. 关闭文件

- close() 方法的功能仅是切断文件流与文件之间的关联，该文件流并不会被销毁，其后续还可用于关联其它的文件

- ```c++
  void close( )
  ```

- 流状态：当文件流对象未关联任何文件时，调用 close() 方法会失败，其会为文件流设置 failbit 状态标志，该标志可以被 fail() 成员方法捕获

#### 6. 关闭文件：刷新缓冲

- C++ 中使用 open() 打开的文件，在读写操作执行完毕后，应及时调用 close() 方法关闭文件，或者对文件执行写操作后及时调用 flush() 方法刷新输出流缓冲区

#### 7. 文本文件

- 操作方式
  - 文本形式
    - 举个例子，假设我们以文本形式将浮点数 19.625 写入文件，则该文件会直接将 "19.625" 这个字符串存储起来
    - 使用 >> 和 << 读写文件：适用于以文本形式读写文件
  - 二进制形式
    - 但如果以二进制形式将浮点数 19.625 写入文件，则该文件存储的是 19.625 浮点数对应的二进制数据
    - 使用 read() 和 write() 成员方法读写文件：适用于以二进制形式读写文件

#### 8. 二进制文件

- 写文件

  - ```c++
    ostream & write(char* buffer, int count);
    ```

  - 将内存中 buffer 指向的 count 个字节的内容写入文件

  - 调用 write() 函数时并没有指定这些字节写入文件中的具体位置，write() 方法会从文件写指针指向的位置将二进制数据写入

  - 文件写指针，是 ofstream 或 fstream 对象内部维护的一个变量，文件刚打开时，文件写指针指向的是文件的开头（如果以  ios::app 方式打开，则指向文件末尾），用 write() 方法写入 n 个字节，写指针指向的位置就向后移动 n 个字节

- 读文件

  - ```c++
    istream & read(char* buffer, int count);
    ```

  - 从文件中读取 count 个字节的数据存入 buffer

  - 和 write() 方法类似，read() 方法从文件读指针指向的位置开始读取若干字节

  - 在使用 read() 方法的同时，如果想知道一共成功读取了多少个字节（读到文件尾时，未必能读取 count 个字节），可以在 read() 方法执行后立即调用文件流对象的 gcount() 成员方法，其返回值就是最近一次 read() 方法成功读取的字节数

#### 9. 文本文件：逐个读写字符

- put()

  - ```c++
    ostream& put (char c);
    ```

- get()

  - ```c++
    int get();
    istream& get (char& c);
    ```

  - 第一种语法格式的返回值就是读取到的字符，只不过返回的是它的 ASCII 码，如果碰到输入的末尾，则返回值为 EOF

  - 第二种语法格式需要传递一个字符变量，get() 方法会自行将读取到的字符赋值给这个变量

  - 和 put() 方法一样，操作系统在接收到 get() 方法的请求后，哪怕只读取一个字符，也会一次性从文件中将很多数据（通常至少是 512 个字节，因为硬盘的一个扇区是 512 B）读到一块内存空间中（可称为文件流输入缓冲区）

  - 这样当读取下一个字符时，就不需要再访问硬盘中的文件，直接从该缓冲区中读取即可

#### 10. 文本文件：读取一行字符

- ```c++
  istream & getline(char* buf, int bufSize);
  istream & getline(char* buf, int bufSize, char delim);
  ```

- 第一种语法格式用于从文件输入流缓冲区中读取 bufSize-1 个字符到 buf，或遇到 \n 为止（哪个条件先满足就按哪个执行），该方法会自动在 buf 中读入数据的结尾添加 '\0'

- 第二种语法格式和第一种的区别在于，第一个版本是读到 \n 为止，第二个版本是读到 delim 字符为止。\n 或 delim 都不会被读入 buf，但会被从文件输入流缓冲区中取走

- 注意，如果文件输入流中 \n 或 delim 之前的字符个数达到或超过 bufSize，就会导致读取失败

#### 11. 文件读写指针

- In streams supporting both read and write, you actually have two  positions, one for read (i.e. "get" denoted by "g") and one for write  (i.e. "put" denoted by a "p")

- 读指针

  - ```c++
    istream & seekg (int offset, int mode);
    int tellg();
    ```

  - ifstream 类和 fstream 类有 seekg 成员函数，可以设置文件读指针的位置
  - tellg 成员函数，能够返回文件读指针的位置
  - 要获取文件长度，可以用 seekg 函数将文件读指针定位到文件尾部，再用 tellg 函数获取文件读指针的位置，此位置即为文件长度

- 写指针

  - ```c++
    ostream & seekp (int offset, int mode);
    int tellp();
    ```

  - ofstream 类和 fstream 类有 seekp 成员函数，可以设置文件写指针的位置
  - tellp 成员函数，能够返回文件写指针的位置

- 设置模式

  - mode 代表文件读写指针的设置模式
  - ios::beg：让文件读指针（或写指针）指向从文件开始向后的 offset 字节处。offset 等于 0 即代表文件开头。在此情况下，offset 只能是非负数
  - ios::cur：在此情况下，offset 为负数则表示将读指针（或写指针）从当前位置朝文件开头方向移动 offset 字节，为正数则表示将读指针（或写指针）从当前位置朝文件尾部移动 offset字节，为 0 则不移动
  - ios::end：让文件读指针（或写指针）指向从文件结尾往前的 |offset|（offset 的绝对值）字节处。在此情况下，offset 只能是 0 或者负数



### 第十二章 多文件编程

#### 1. 简介

- C++ 项目
  - .h 文件：又称“头文件”，用于存放常量、函数的声明部分、类的声明部分
  - .cpp 文件：又称“源文件”，用于存放变量、函数的定义部分，类的实现部分

#### 2. 避免头文件重复引入

- 使用宏定义避免重复引入

  - ```c++
    #ifndef _NAME_H
    #define _NAME_H
    //头文件内容
    #endif
    ```

  - 这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同

- 使用 `#pragma once` 避免重复引入

  - 在 C/C++ 中，#pragma once 是一个非标准但却逐渐被很多编译器支持的指令
  - 将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次
  - 和 ifndef 相比，#pragma once 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高
  - 但值得一提的是，并不是每个版本的编译器都能识别 #pragma once 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 #pragma once 指令的兼容性不是很好

- 使用_Pragma操作符

  - `_Pragma("once")`
  - C99 标准中新增加了一个和 #pragma 指令类似的 _Pragma 操作符，其可以看做是 #pragma 的增强版

- 小结

  - 后两类编译效率高，但可移植性差（编译器不支持，会发出警告，但不会中断程序的执行）；而 #ifndef 的特点是可移植性高，编译效率差
  - 除非对项目的编译效率有严格的要求，强烈推荐读者选用第一种解决方案，即采用 #ifndef / #define / #endif 组合解决头文件被重复引入
  - 另外在某些场景中，考虑到编译效率和可移植性，#pragma once 和 #ifndef 经常被结合使用来避免头文件被重复引入

#### 3. 命名空间

- 如果要给变量、函数或者类指定命名空间，则该命令空间应至少包含它们的声明部分。所以当进行多文件编程时，命名空间常位于 .h 头文件中
- 当类的声明位于指定的命名空间中时，如果要在类的外部实现其成员方法，需同时注明所在命名空间名和类名（例如本项目中的 Li::Student::display() ）
- 分散在不同文件中的同名命名空间会合并为一个，所以不同头文件中也可以使用名称相同的命名空间，但前提是位于该命名空间中的成员必须保证互不相同

#### 4. 常量

- 回顾：const
  - 用 const 修饰的变量必须在定义的同时进行初始化操作（除非用 extern 修饰）
  - const 还将所修饰变量的可见范围限制为当前文件
- 将const常量定义在.h头文件中
  - 第一种方式更简单、更常用，推荐读者使用
- 借助extern先声明再定义const常量
  - extern 关键字会抵消 const 限定可见范围的功能，它可以使 const 常量的可见范围恢复至整个项目

- 借助extern直接定义const常量
  - 省略了 demo.h 头文件的创建，一定程序上提高了项目的编译效率

#### 5. 编译命令

- 预处理

  - ```shell
    [root@bogon ~]# g++ -E main.cpp -o main.i
    ```

- 编译

  - 对预处理阶段得到的 -i 文件做进一步的语法分析，生成相应的汇编代码文件

  - ```shell
    g++ -S main.i -o main.s
    ```

- 汇编

  - 将汇编代码文件转换成可以执行的机器指令

  - ```shell
    g++ -c main.s -o main.o
    ```

- 链接

  - 将所有的目标文件组织成一个可以执行的二进制文件

  - ```c++
    g++ main.o student.o -o student.exe
    ```

- 整合成一条命令

  - ```shell
    g++ main.cpp student.cpp -o student.exe
    ```

#### 6. 总结

- 回顾

  - 在 C++ 项目中，一个符号允许被声明多次，但只能被定义一次
  - .h 头文件的作用就是被其它的 .cpp 包含进去，其本身并不参与编译，但实际上它们的内容会在多个 .cpp 文件中得到编译

- 头文件

  - 只能存放声明

    - ```c++
      extern int a;
      void f();
      ```

  - 不能存放定义

    - ```c++
      int a;
      void f() {}
      ```
  
  - 如果把定义存放在 .h 文件中，一旦该文件被 2 个以上的 .cpp 文件引入，编译器就会立马报错
  
- 例外

  - 头文件中可以定义 const 对象
    - 全局的 const 对象默认是没有 extern 声明的，只在当前文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义
    - 同理，static 对象的定义也可以放进头文件
  - 头文件中可以定义内联函数
    - 编译器必须在编译时就找到内联函数的完整定义
  - 头文件中可以定义类

- 为什么不能重复引入

  - 如果 .h 头文件中只包含声明语句的话，即便被同一个 .cpp 文件引入多次也没有问题，因为声明语句是可以重复的，且重复次数不受限制
  - 如果一个头文件中出现了上面 3 种情况中的任何一种，且被同一个 .cpp 文件引入多次，就会发生重定义错误

