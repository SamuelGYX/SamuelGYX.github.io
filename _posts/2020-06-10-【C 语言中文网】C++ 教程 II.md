---
layout: post
title:  【C 语言中文网】C++ 教程笔记 第二部分
date:   2020-06-10
categories: C++
---

### 第五章 多态与虚函数

- 面向对象程序设计语言有**<u>封装</u>**、**<u>继承</u>**和**<u>多态</u>**三种机制，这三种机制能够有效提高程序的可读性、可扩充性和可重用性
- “多态（polymorphism）”指的是同一名字的事物可以完成不同的功能。
  - 编译时的多态：主要指函数的重载（包括运算符的重载）、对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数
  - 运行时的多态：和继承、虚函数等概念有关，是本章要讲述的内容

#### 1. 基本概念

- 起因
  - 回顾：将派生类指针赋值给基类指针后，通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数
- 用法
  - 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员
  - 多态是面向对象编程的主要特征之一，C++中虚函数的唯一用处就是构成多态
  - 通过指针调用普通的成员函数时会根据指针的类型来判断调用哪个类的成员函数，但是虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数
  - 引用在本质上是通过指针的方式实现的，因此借助引用也可以实现多态
- 用途
  - 在派生类比较多的场景中，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个基类指针变量就可以调用所有派生类的虚函数
  - 对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力

#### 2. 虚函数

- 注意事项
  - 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加
  - 可以只将基类中的函数声明为虚函数，所有派生类中具有**<u>遮蔽</u>**关系的同名函数都将自动成为虚函数
  - 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数
  - 只有派生类的虚函数**<u>覆盖</u>**基类的虚函数（函数原型相同）才能构成多态（通过基类[指针](http://c.biancheng.net/c/80/)访问派生类函数）
  - **<u>构造函数</u>**不能是虚函数，因为派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义
  - **<u>析构函数</u>**可以声明为虚函数，而且有时候必须要声明为虚函数
- 构成多态的条件
  - 必须存在继承关系
  - 继承关系中必须有同名的虚函数，并且它们是**<u>覆盖</u>**关系（函数原型相同）
  - 存在基类的指针，通过该指针调用虚函数
- 何时使用
  - 成员函数所在的类会被作为基类
  - 成员函数在类的继承后有可能被更改功能

#### 3. 虚函数：构造函数与析构函数

- 构造函数不能被声明为虚函数
  - 派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义
  - 构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数
- 析构函数一般都要声明为虚函数
  - 若父类指针指向子类对象，释放内存时只会调用父类自己的析构函数
  - 将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数，这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数
  - 因此基类的析构函数在大部分情况下都应该被声明为虚函数，否则就有内存泄露的风险

#### 4. 虚函数：纯虚函数和抽象类

- 用法

  - 在[C++](http://c.biancheng.net/cplus/)中，可以将虚函数声明为纯虚函数，包含纯虚函数的类称为抽象类，无法实例化

  - 抽象类通常是作为基类，让派生类去实现纯虚函数，派生类必须实现纯虚函数才能被实例化

  - 语法

    ```c++
    virtual 返回值类型 函数名 (函数参数) = 0;
    ```

  - 纯虚函数也是虚函数，因此也可以实现多态

- 注意

  - 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量
  - 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数

#### 5. 虚函数：虚函数表

- 原理
  - 如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址，这个数组就叫做虚函数表（Virtual function table），简写为 `vtable`
  - 不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针 `vfptr`，指向数组的起始位置
  - `( *( *(p+0) + 虚函数在表中的索引 ) )(p);`
- 特点
  - 基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在 vtable 的最后
  - 如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在 vtable 中只会出现一次
- 多继承，虚继承
  - 虚函数表的结构就会变得复杂，还会增加虚基类表，此处暂略

#### 6. RTTI：typeid 运算符

- 用法
  - typeid 运算符用来获取一个表达式的类型信息
  - 类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定
  - typeid 的使用非常灵活，它的操作数可以是普通变量、对象、内置类型（int、float等）、自定义类型（结构体和类），还可以是一个表达式
  - 不像 [Java](http://c.biancheng.net/java/)、[C#](http://c.biancheng.net/csharp/) 等动态性较强的语言，C++ 能获取到的类型信息非常有限，也没有统一的标准，如同“鸡肋”一般，大部分情况下我们只是使用重载过的“==”运算符来判断两个类型是否相同

- 成员函数：C++ 标准规定，type_info 类至少要有如下所示的 4 个 public 属性的成员函数
  - `const char* name() const;`
    - 返回一个能表示类型名称的字符串
  - `bool before (const type_info& rhs) const;`
    - 判断一个类型是否位于另一个类型的前面，但是C++标准并没有规定类型的排列顺序，不同的编译器有不同的排列规则，程序员也可以自定义
  - `bool operator== (const type_info& rhs) const;`
    - 重载运算符“==”，判断两个类型是否相同
  - `bool operator!= (const type_info& rhs) const;`
    - 重载运算符“!=”，判断两个类型是否不同
  - 它的构造函数是 private 属性的，所以不能在代码中直接实例化，只能由编译器在内部实例化（借助友元）。而且还重载了“=”运算符，也是 private 属性的，所以也不能赋值
- 注意
  - 一个类型不管使用了多少次，编译器都只为它创建一个对象，所有 typeid 都返回这个对象的引用
  - 为了减小编译后文件的体积，编译器不会为所有的类型创建 type_info 对象，只会为使用了 typeid 运算符的类型创建
  - 不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用 typeid 运算符，编译器都会为带虚函数的类创建 type_info 对象
  - 即使将派生类[指针](http://c.biancheng.net/c/80/) p2 赋值给基类指针 p1，p1 的类型仍然为 Base*

#### 7. RTTI：运行时类型识别机制

- 回顾：对象内存模型
  - 如果没有虚函数也没有虚继承，那么对象内存模型中只有成员变量
  - 如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表
  - 如果类包含了虚继承，那么会额外添加一个虚基类表，并在对象内存中插入一个指针，指向这个虚基类表
- 补充：
  - 如果类包含了虚函数，编译器会在虚函数表 vftable 的开头插入一个指针，指向当前类对应的 type_info 对象，用于在运行阶段获取类型信息
  - `**(p->vfptr - 1)` 或者 `**(*(p+0) - 1)`

- 运行时类型识别
  - 这种在程序运行后确定对象的类型信息的机制称为运行时类型识别（Run-Time Type Identification，RTTI）
  - 在 C++ 中，只有类中包含了虚函数时才会启用 RTTI 机制，其他所有情况都可以在编译阶段确定类型信息
- 多态
  - 多态（Polymorphism）是面向对象编程的一个重要特征，它极大地增加了程序的灵活性，C++、C#、Java  等“正统的”面向对象编程语言都支持多态
  - 但是支持多态的代价也是很大的，有些信息在编译阶段无法确定下来，必须提前做好充足的准备，让程序运行后再执行一段代码获取，这会消耗更多的内存和 CPU 资源

#### 8. RTTI：静态绑定和动态绑定

- 符号绑定
  - 变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址
  - 编译和链接过程的一项重要任务就是找到这些名称所对应的地址，这个过程就叫做符号绑定
- 分类
  - 一般情况下，在编译期间（包括链接期间）就能找到函数名对应的地址，完成函数的绑定，程序运行后直接使用这个地址即可。这称为静态绑定（Static binding）
  - 但是有时候在编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定。这称为动态绑定（dynamic binding）
  - 使用动态绑定常常是因为编译器在编译期间不能确定**<u>指针</u>**指向哪个对象

#### 9. RTTI：内存模型

- 继承链
  - 我们必须要在基类和派生类之间再增加一条`绳索`，把它们`连接`起来，形成一条通路，让程序在各个对象之间`游走`。在面向对象的编程语言中，我们称此为继承链（Inheritance Chain）
  - 对于有虚函数的类，内存模型中除了有虚函数表，还会额外增加好几个表，以维护当前类和基类的信息，空间上的开销不小
  - 具体内存模型过于复杂，暂略

- 注意
  - typeid 经过固定次数的间接转换返回 type_info 对象，间接次数不会随着继承层次的增加而增加，对效率的影响很小，读者可以放心使用
  - 而 dynamic_cast 运算符和异常处理不仅要经过数次间接转换，还要遍历继承链，如果继承层次较深，那么它们的性能堪忧，读者应当谨慎使用！
- 静态语言与动态语言
  - 静态语言
    - 静态语言在定义变量时通常需要显式地指明类型，并且在编译期间会拼尽全力来确定表达式的类型信息，只有在万不得已时才让程序等到运行后动态地获取类型信息（例如多态），这样的编程语言称为静态语言（Static Language）
    - 除了 C/C++，典型的静态语言还有 Java、C#、Haskell、Scala 等
    - 静态语言由于类型的限制会降低编码的速度，但是它的执行效率高，适合开发大型的、系统级的程序
  - 动态语言
    - 动态语言在定义变量时往往不需要指明类型，并且变量的类型可以随时改变（赋给它不同类型的数据），编译器在编译期间也不容易确定表达式的类型信息，只能等到程序运行后再动态地获取
    - 动态语言为了能够使用灵活，部署简单，往往是一边编译一边执行，模糊了传统的编译和运行的过程
    - 典型的动态语言有 JavaScript、Python、PHP、Perl、Ruby 等
    - 动态语言比较灵活，编码简单，部署容易，在 Web 开发中大显身手



### 第六章 运算符重载

#### 1. 基本概念

- 简介

  - 运算符重载（Operator Overloading）：使同一个运算符可以有不同的功能
  - 运算符重载是通过函数实现的，它本质上是函数重载
  - 运算符重载所实现的功能完全可以用函数替代，但运算符重载使得程序的书写更加人性化，易于阅读

- 分类

  - 通过成员函数实现

    - 举例
      
      ```c++
      complex complex::operator+(const complex &A) const{
        return complex(this->m_real + A.m_real, this->m_imag + A.m_imag);
      }
      ```
      
    - `c3 = c1.operator+(c2);`
    
  - 通过全局函数实现

    - 举例

      ```c++
      complex operator+(const complex &A, const complex &B){
        return complex(B->m_real + A.m_real, B->m_imag + A.m_imag);
      }
      ```

    - `c3 = operator+(c1, c2);`

#### 2. 规则

- 并不是所有的运算符都可以重载
  - 能够重载的运算符：`+ - * / % ^ & | ~ ! = < > += -= *= /= %= ^=  &= |=  << >> <<= >>= == != <=  >= && || ++ -- , ->* -> () []  new new[]  delete delete[]`
  - 不能重载的运算符：`sizeof :? . ::`
- 重载不能改变运算符的优先级和结合性
- 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变
- 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的
- 运算符重载函数既可以作为类的成员函数，也可以作为全局函数
  - 将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数，因为成员函数多一个隐含的 `this` 参数
  - 将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且至少有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质
  - 将运算符重载函数作为全局函数时，为了访问 private 成员，一般都需要在类中将该函数声明为友元函数
- 箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载

#### 3. 数学运算符举例

- 数学运算符
  - 四则运算符：`+、-、*、/、+=、-=、*=、/=`
  - 和关系运算符：`\>、<、<=、>=、==、!=`

#### 4. 成员函数还是全局函数

- 转换构造函数
  - `Complex(double real);` 在作为普通构造函数的同时，还能将 double 类型转换为 Complex 类型，集合了“构造函数”和“类型转换”的功能，所以被称为「转换构造函数」
- 使用全局函数的好处
  - 两个操作数中任意一个为对象时，如果定义了对应的转换构造函数，那么另一个操作符就会被转化为对象，然后进行运算
  - 如果两个操作数都不能转换为和对方匹配的类型，或者都能成功转换（产生了二义性），才报错
  - 使用全局函数重载运算符保证操作数能够被对称地处理（不管是在操作符左边或者右边）
- 使用成员函数的好处
  - 运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的
  - C++ 只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换
  - 因此把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换

- 总结
  - 有一部分运算符重载既可以是成员函数也可以是全局函数，我们应该优先考虑成员函数，这样更符合运算符重载的初衷
  - 有一部分运算符重载必须是全局函数，这样能保证参数的对称性
  - 另外，C++ 规定，箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载

#### 5. `<<` 和 `>>`

- 输入运算符 `>>`

  - 举例

    ```c++
    istream & operator>>(istream &in, complex &A){
      in >> A.m_real >> A.m_imag;
      return in;
    }
    ```

  - `operator>>(cin, c);`
  - 注意
    - 必须以全局函数（友元函数）的形式重载 `<<` 和 `>>`
    - 运算符重载函数中用到了 complex 类的 private 成员变量，必须在 complex 类中将该函数声明为友元函数
    - 返回 istream 类对象的引用，是为了能够连续读取复数，让代码书写更加漂亮

- 输出运算符 `<<`

  - 举例

    ```c++
    ostream & operator<<(ostream &out, complex &A){
      out << A.m_real <<" + "<< A.m_imag <<" i ";
      return out;
    }
    ```

#### 6. `[]`

- [C++](http://c.biancheng.net/cplus/) 规定，下标运算符`[ ]`必须以成员函数的形式进行重载
- 声明格式
  - `返回值类型 & operator[ ] (参数);`
    - 可以访问元素，还可以修改元素
  - `const 返回值类型 & operator[ ] (参数) const;`
    - 只能访问而不能修改元素
    - [通过 const 对象只能调用 const 成员函数](http://c.biancheng.net/view/2232.html)，如果不提供第二种形式，那么将无法访问 const 对象的任何元素
- `arr.operator[ ](i);`

#### 7. `++` 和 `--`

- 声明格式

  ```c++
  对象 operator++();  //++i，前置形式
  对象 operator++(int);  //i++，后置形式，在这个函数中参数 int n 是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式
  ```

#### 8. `new` 和 `delete`

- `new` 运算符

  - ```c++
    // 成员函数
    void * className::operator new( size_t size ){
        //TODO:
    }
    // 全局函数
    void * operator new( size_t size ){
        //TODO:
    }
    ```
  
- 无论是作为成员函数还是作为全局函数，它的第一个参数必须是 size_t 类型
  
- size_t 表示的是要分配空间的大小，对于 new[] 的重载函数而言，size_t 则表示所需要分配的所有空间的总和
  
- 重载函数也可以有其他参数，但都必须有默认值
  
- `delete` 运算符

  - ```c++
    // 成员函数
    void className::operator delete( void *ptr){
        //TODO:
    }
    // 全局函数
    void operator delete( void *ptr){
        //TODO:
    }
    ```
  
- 如果类中没有定义 new 和 delete 的重载函数，那么会自动调用内建的 new 和 delete 运算符

#### 9. `()`

- 在 [C++](http://c.biancheng.net/cplus/) 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符

- 类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数

- 举例

  - ```c++
    // 声明
    operator double() { return real; }  //重载强制类型转换运算符 double
    
    // 使用
    Complex c(1.2, 3.4);
    double n = 2 + c; // 等价于 double n = 2 + c.operator double()
    ```

  - 有了对 double 运算符的重载，在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用

#### 10. 其他

- 必要时需要重载赋值运算符=，以避免两个对象内部的[指针](http://c.biancheng.net/c/80/)指向同一片存储空间
- <<和>>是在 iostream 中被重载，才成为所谓的“流插入运算符”和“流提取运算符”的



### 第七章 模板和泛型程序设计

- 泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法
- 所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型
- 泛型程序设计方法的优势在于能够减少重复代码的编写
- 泛型程序设计的概念最早出现于 1983 年的 Ada 语言，其最成功的应用就是 C++ 的标准模板库（STL）
- 在 C++ 中，模板分为函数模板和类模板两种

#### 1. 函数模版

- 起因

  - 普通函数：数据的值（Value）可以通过函数参数传递，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。这就是值的参数化
  - 模版函数：数据的类型（Type）也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化

- 用法

  - 实例

    - ```c++
      template <typename 类型参数1 , typename 类型参数2 , ...> // 模版头
      返回值类型  函数名(形参列表){
          //在函数体中可以使用类型参数
      }
      ```

  - 说明

    - 类型参数列表以`< >`包围，形式参数列表以`( )`包围
    - `typename`关键字也可以使用`class`关键字替代，它们没有任何区别
    - 函数模板也可以提前声明，不过声明时需要带上模板头
    - 模板头和函数定义（声明）是一个不可分割的整体，它们可以换行，但中间不能有分号

#### 2. 类模版

- 声明

  - ```c++
     template<typename 类型参数1, typename 类型参数2, ...> class 类名{
        //TODO:
    };
    ```

  - ```c++
    template<typename 类型参数1, typename 类型参数2, ...>
    返回值类型 类名<类型参数1, 类型参数2, ...>::函数名(形参列表){
        //TODO:
    }
    ```

- 使用

  - ```c++
    类名<类型参数列表> 实例名(参数列表);
    类名<类型参数列表> *指针名 = new 类名<类型参数列表>(参数列表);
    ```

#### 3. 模版：来龙去脉

- 编程语言分类
  - 强类型语言
    - 强类型语言在定义变量时需要显式地指明数据类型，并且一旦为变量指明了某种数据类型，该变量以后就不能被赋予其他类型的数据了
    - 对于强类型的语言，变量的类型从始至终都是确定的、不变的，编译器在编译期间就能检测某个变量的操作是否正确，这样最终生成的程序中就不用再维护一套类型信息了，从而减少了内存的使用，加快了程序的运行
    - 我们将传统的先编译后执行的语言称为**<u>编译型语言</u>**
    - 强类型语言较为严谨，在编译时就能发现很多错误，适合开发大型的、系统级的、工业级的项目
    - 另外，强类型语言的 IDE 一般都比较强大，代码感知能力好，提示信息丰富
    - C/[C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/)、[C#](http://c.biancheng.net/csharp/)
  - 弱类型语言
    - 弱类型语言在定义变量时不需要显式地指明数据类型，编译器（解释器）会根据赋给变量的数据自动推导出类型，并且可以赋给变量不同类型的数据
    - 弱类型语言往往是一边执行一边编译，这样可以根据上下文（可以理解为当前的执行环境）推导出很多有用信息，让编译更加高效
    - 我们将这种一边执行一边编译的语言称为**<u>解释型语言</u>**
    - 弱类型语言较为灵活，编码效率高，部署容易，学习成本低，在 Web 开发中大显身手
    - 弱类型语言一般都是在编辑器中直接书写代码
    - [JavaScript](http://c.biancheng.net/js/)、[Python](http://c.biancheng.net/python/)、[PHP](http://c.biancheng.net/php/)、Ruby、Shell、Perl

- 起因
  - C++ 模板也是被迫推出的，最直接的动力来源于对[数据结构](http://c.biancheng.net/data_structure/)的封装
  - C++ 开发者们希望为线性表、链表、图、树等常见的数据结构都定义一个类，并把它们加入到标准库中，这样以后程序员就不用重复造轮子了，直接拿来使用即可
  - 但是这个时候遇到了一个无法解决的问题，就是数据结构中每份数据的类型无法提前预测
  - 模板一般在强类型语言中使用

#### 4. 函数模版：重载

- C++ 允许对函数模板进行重载，程序员可以像重载常规函数那样重载模板定义

- ```c++
  template<class T> void Swap(T &a, T &b);  //模板①：交换基本类型的值
  template<typename T> void Swap(T a[], T b[], int len);  //模板②：交换两个数组
  ```

#### 5. 函数模版：类型实参推断

- 普通函数的类型转换
  - 算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等
  - 派生类向基类的转换：也就是向上转型
  - const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *
  - 数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针
  - 用户自定的类型转换
- 模版函数的类型转换
  - 对于函数模板，类型转换受到了更多的限制，仅能进行「const 转换」和「数组或函数指针转换」，其他的都不能应用于函数模板
  - 注意：当函数形参是引用类型时，数组不会转换为指针
- 为函数模板显式地指明实参
  - 「为函数模板显式地指明实参」和「为类模板显式地指明实参」的形式是类似的，就是在函数名后面添加尖括号`< >`，里面包含具体的类型
  - 显式指明的模板实参会按照从左到右的顺序与对应的模板参数匹配，只有尾部的类型参数的实参可以省略，前提是它们可以从传递给函数的实参中推断出来
  - 注意：显式地指明实参时可以应用正常的类型转换

#### 6. 模版：显式具体化

- 函数模板

  - ```c++
    //函数模板
    template<class T> const T& Max(const T& a, const T& b);
    //函数模板的显示具体化（针对STU类型的显示具体化）
    // Max<STU> 中的 STU 可以省略
    template<> const STU& Max<STU>(const STU& a, const STU& b);
    ```

  - 在 C++ 中，对于给定的函数名，在调用函数时，非模板函数 > 显示具体化 > 常规模板

- 类模版

  - 显示具体化

    - ```c++
      //类模板
      template<class T1, class T2> class Point{
      public:
          Point(T1 x, T2 y): m_x(x), m_y(y){ }
          void display() const;
      private:
          T1 m_x;
          T2 m_y;
      };
      template<class T1, class T2>  //这里要带上模板头
      void Point<T1, T2>::display() const{
          cout<<"x="<<m_x<<", y="<<m_y<<endl;
      }

      //类模板的显示具体化（针对字符串类型的显示具体化）
      template<> class Point<char*, char*>{
      public:
          Point(char *x, char *y): m_x(x), m_y(y){ }
          void display() const;
      private:
          char *m_x;  //x坐标
          char *m_y;  //y坐标
      };
      //这里不能带模板头template<>
      void Point<char*, char*>::display() const{
          cout<<"x="<<m_x<<" | y="<<m_y<<endl;
      }
      ```

    - 注意：当在类的外部定义成员函数时，普通类模板的成员函数前面要带上模板头，而具体化的类模板的成员函数前面**<u>不能带模板头</u>**
    
  - 部分显式具体化
  
    -  C++ 允许只为一部分类型参数提供实参，这称为部分显式具体化
    - 模板头`template<typename T2>`中声明的是没有被具体化的类型参数；类名`Point<char*, T2>`列出了所有类型参数，包括未被具体化的和已经被具体化的
    - 注意：当在类的外部定义成员函数时，部分显示具体化的类模板的成员函数，前面**<u>需要带模板头</u>**

#### 7. 模版：非类型参数

- 使用

  - 当调用一个函数模板或者通过一个类模板创建对象时，非类型参数会被用户提供的、或者编译器推断出的值所取代

  - ```c++
    template<class T, int N> void func(T (&arr)[N]);
    ```

  - ```c++
    template<typename T, int N>
    class Array{
    public:
        Array();
        ~Array();
    public:
        T & operator[](int i);  //重载下标运算符[]
        int length() const { return m_length; }  //获取数组长度
        bool capacity(int n);  //改变数组容量
    private:
        int m_length;  //数组的当前长度
        int m_capacity;  //当前内存的容量（能容乃的元素的个数）
        T *m_p;  //指向数组内存的指针
    };
    
    int main() {
        Array<int, 5> arr;
    }
    ```

- 限制

  - 非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个整数，或者是一个指向对象或函数的指针（也可以是引用）
  - 当非类型参数是一个整数时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式
  - 当非类型参数是一个指针（引用）时，绑定到该指针的实参必须具有静态的生存期；换句话说，实参必须存储在虚拟地址空间中的静态数据区。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参

#### 8. 模版：实例化

- 实例化
  - 模板不会占用内存，最终生成的函数或者类才会占用内存
  - 由模板生成函数或类的过程叫做模板的实例化（Instantiate），相应地，针对某个类型生成的特定版本的函数或类叫做模板的一个实例（Instantiation）
  - 模板也可以看做是编译器的一组指令，它命令编译器生成我们想要的代码
  - 模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码，并且相同的类型只生成一次

- 类模板
  - 类模版的实例化是延迟的、局部的
  - 通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化；如果一个成员函数永远不会被调用，那它就永远不会被实例化

#### 9. 模版：多文件编程

- 多文件编程
  - 在将函数应用于多文件编程时，我们通常是将函数定义放在源文件（`.cpp`文件）中，将函数声明放在头文件（`.h`文件）中，使用函数时引入（`#include`命令）对应的头文件即可
  - 但是在模版编程中，**<u>不能</u>**将模板的声明和定义分散到多个文件中，惯用的做法是将模板的声明和定义都放到头文件中
- 分析
  - 编译是针对单个源文件的，只要有函数声明，编译器就能知道函数调用是否正确；而将函数调用和函数定义对应起来的过程，可以延迟到链接时期。正是有了链接器的存在，函数声明和函数定义的分离才得以实现
  - 模板的实例化是按需进行的，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码
  - 模板的实例化是由**<u>编译器</u>**完成的，而不是由链接器完成的
  - 在实例化过程中需要知道模板的所有细节，包含声明和定义，如果只有声明没有定义，编译器会生成失败，不过这个时候编译器不会报错，而是对该函数的调用做一个记录，希望等到链接程序时在其他目标文件（.obj 文件或 .o 文件）中找到该函数的定义
  - 如果链接器最终也找不到所需版本的函数定义，只能抛出一个链接错误，让程序员修改代码

#### 10. 模版：显示实例化

- 分类

  - 隐式实例化：调用函数或者创建对象时由编译器自动完成的，不需要程序员引导
  - 显式实例化：提前（真正调用前）通过代码明确地告诉编译器需要针对哪个类型进行实例化
    - 必须将显式实例化的代码放在包含了模板定义的源文件中，而不是仅仅包含了模板声明的头文件中
    - C++ 支持显式实例化的目的是为「模块化编程」提供一种解决方案
    - 缺陷：程序员必须要在模板的定义文件（实现文件）中对所有使用到的类型进行实例化
    - 如果我们开发的模板只有我们自己使用，那也可以勉强使用显式实例化；如果希望让其他人使用（例如库、组件等），那只能将模板的声明和定义都放到头文件中了

- 使用

  - ```c++
    //实例化定义
    template declaration;
    //实例化声明，也可以省略，即使不写，编译器发现当前文件中没有对应的模板定义，也会自动去其他文件中查找
    extern template declaration;  
    ```

  - 对于函数模板来说，declaration 就是一个函数原型；对于类模板来说，declaration 就是一个类声明

  - 注意：显式实例化一个类模板时，会一次性实例化该类的所有成员，包括成员变量和成员函数

#### 11. 类模版：继承

- 类模板从类模板派生

  - ```c++
    template <class T1, class T2>
    class A { Tl v1; T2 v2; };
    
    template <class T1, class T2>
    class B : public A <T2, T1> { T1 v3; T2 v4; };
    ```

- 类模板从模板类派生

  - ```c++
    template<class T1, class T2>
    class A{ T1 v1; T2 v2; };
    
    template <class T>
    class B: public A <int, double>{T v;};
    ```

- 类模板从普通类派生

  - ```c++
    class A{ int v1; };
    
    template<class T>
    class B: public A{ T v; };
    ```

- 普通类从模板类派生

  - ```c++
    template <class T>
    class A{ T v1; int n; };
    
    class B: public A <int> { double v; };
    ```

#### 12. 类模版：友元

- 函数、类、类的成员函数作为类模板的友元

  - ```c++
    template <class T>
    class Tmpl
    {
        friend void Func1();
        friend class A;
        friend void B::Func();
    };
    ```

- 函数模板作为类模板的友元

  - ```c++
    template <class T1, class T2>
    class Pair
    {
    private:
        T1 key; T2 value;
    public:
        Pair(T1 k, T2 v) : key(k), value(v) { };
        template <class T3, class T4>
        friend ostream & operator << (ostream & o, const Pair<T3, T4> & p);
    };
    template <class Tl, class T2>
    ostream & operator << (ostream & o, const Pair<T1, T2> & p)
    {
        o << "(" << p.key << "," << p.value << ")";
        return o;
    }
    ```

- 函数模板作为类的友元

  - ```c++
    class A
    {
        int v;
    public:
        A(int n) :v(n) { }
        template <class T>
        friend void Print(const T & p);
    };
    template <class T>
    void Print(const T & p) { cout << p.v; }
    ```

- 类模板作为类模板的友元

  - ```c++
    template<class T>
    class A
    {
    public:
        void Func(const T & p) { cout << p.v; }
    };
    template <class T>
    class B
    {
    private:
        T v;
    public:
        B(T n) : v(n) { }
        template <class T2>
        friend class A;  //把类模板A声明为友元
    };
    ```

#### 13. 类模版：静态成员

- ```c++
  template <class T>
  class A
  {
  private:
      static int count;
  public:
      A() { count ++; }
      ~A() { count -- ; };
      A(A &) { count ++ ; }
      static void PrintCount() { cout << count << endl; }
  };
  // 必须对静态成员变量在类外部加以声明
  template<> int A<int>::count = 0;
  template<> int A<double>::count = 0;
  int main()
  {
      A<int> ia;
      A<double> da;
      ia.PrintCount(); // 1
      da.PrintCount(); // 1
      return 0;
  }
  ```



### 第八章 异常

#### 1. 简介

- 错误

  - 语法错误
  - 逻辑错误
  - 运行时错误
    - [C++](http://c.biancheng.net/cplus/) 异常（Exception）机制就是为解决运行时错误而引入的

- 捕获异常

  - ```c++
    try{
        // 可能抛出异常的语句
    }catch(exceptionType variable){
        // 处理异常的语句
    }
    ```

  - 发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到

  - 检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置

  - 执行完 catch 块所包含的代码后，程序会继续执行 catch 块后面的代码，就恢复了正常的执行流

- 抛出异常

  - `throw "Unknown Exception";  //抛出异常`
  - 发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见 try 才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了

#### 2. 异常类型

- 类型
  -  规定，异常类型可以是 int、char、float、bool 等基本类型，也可以是[指针](http://c.biancheng.net/c/80/)、数组、字符串、结构体、类等聚合类型
  -  C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常
  -  当异常发生时，程序会按照从上到下的顺序，将异常类型和 catch 所能接收的类型逐个匹配。一旦找到类型匹配的 catch 就停止检索，并将异常交给当前的 catch 处理（其他的 catch 不会被执行）
- 类型转换
  - 回顾：普通函数
    - 算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等
    - 向上转型：也就是派生类向基类的转换
    - const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。
    - 数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针
    - 用户自定的类型转换
  - 回顾：模版函数
    - 「const 转换」
    - 「数组或函数指针转换」
  - 匹配异常
    - 「向上转型」
    - 「const 转换」
    - 「数组或函数指针转换」

#### 3. 抛出异常

- 异常规范
  - `double func (char param) throw (int, char, exception);`
  - 虚函数中的异常规范：派生类虚函数的异常规范必须与基类虚函数的异常规范一样严格，或者更严格
  - 异常规范在函数声明和函数定义中必须同时指明，并且要严格保持一致
  - 异常规范是 C++98 新增的一项功能，但是后来的 C++11 已经将它抛弃了，不再建议使用

#### 4. exception 类

- ```c++
  class exception{
  public:
    exception () throw();  //构造函数
    exception (const exception&) throw();  //拷贝构造函数
    exception& operator= (const exception&) throw();  //运算符重载
    virtual ~exception() throw();  //虚析构函数
    virtual const char* what() const throw();  //虚函数
  }
  ```

- 继承层次

